<ID>1</ID><Size>3387</Size><Creación>Fri Dec  8 10:21:25 2017</Creación><Descripción>addr2line traduce direcciones de programa a nombres de fichero y números de línea Dada una dirección y un ejecutable, emplea la información de depuración en el ejecutable para adivinar qué nombre de f</Descripción>
<ID>2</ID><Size>1380</Size><Creación>Fri Dec  8 10:21:25 2017</Creación><Descripción>Si no se especifica fichero de salida (output_file), la salida va a parar a la salida estándar (stdout) No hay mensajes de error ansi2knr reconoce las funciones buscando algún nombre que no sea identi</Descripción>
<ID>3</ID><Size>552</Size><Creación>Fri Dec  8 10:21:25 2017</Creación><Descripción>apropos busca el contenido de palabra_clave, en una base de datos que contiene breves descripciones de los comandos, mostrando todas las descripciones donde encontra una referencia a la clave VEA TAMB</Descripción>
<ID>4</ID><Size>13246</Size><Creación>Fri Dec  8 10:21:25 2017</Creación><Descripción>El programa de GNU ar crea, modifica, y extrae de archivos Un archivo es un simple fichero que contiene un conjunto de otros ficheros en una estructura que hace posible recuperar los ficheros individu</Descripción>
<ID>5</ID><Size>490</Size><Creación>Fri Dec  8 10:21:25 2017</Creación><Descripción>arch is equivalente a uname -m En los sistemas Linux actuales, arch imprime cosas como "i386", "i486", "i586", "alpha", "sparc", "arm", "m68k", "mips", "ppc" VÉASE TAMBIÉN uname(1), uname(2) Linux 2.0</Descripción>
<ID>6</ID><Size>8819</Size><Creación>Fri Dec  8 10:21:25 2017</Creación><Descripción>GNU as es realmente una familia de ensambladores Si Ud emplea (o ha empleado) el ensamblador de GNU en una arquitectura, debería encontrar un entorno bastante similar cuando lo emplee en otra Cada ver</Descripción>
<ID>7</ID><Size>7587</Size><Creación>Fri Dec  8 10:21:25 2017</Creación><Descripción>at y batch leen comandos desde la entrada estándar o un fichero especificado, los cuales van a ser ejecutados más tarde, utilizando read commands from standard input or a specified file which are to b</Descripción>
<ID>8</ID><Size>7587</Size><Creación>Fri Dec  8 10:21:25 2017</Creación><Descripción>at y batch leen comandos desde la entrada estándar o un fichero especificado, los cuales van a ser ejecutados más tarde, utilizando read commands from standard input or a specified file which are to b</Descripción>
<ID>9</ID><Size>7587</Size><Creación>Fri Dec  8 10:21:25 2017</Creación><Descripción>at y batch leen comandos desde la entrada estándar o un fichero especificado, los cuales van a ser ejecutados más tarde, utilizando read commands from standard input or a specified file which are to b</Descripción>
<ID>10</ID><Size>78360</Size><Creación>Fri Dec  8 10:21:26 2017</Creación><Descripción>Gawk es la implementación del Proyecto GNU del lenguaje de programación AWK Está conforme con la definición del lenguaje en el POSIX 1003.2 Command Language And Utilities Standard Esta versión está ba</Descripción>
<ID>11</ID><Size>1081</Size><Creación>Fri Dec  8 10:21:26 2017</Creación><Descripción>Esta documentación no será mantenida y puede ser inexacta o incompleta La documentación Texinfo es ahora la fuente autorizada Esta página de manual documenta la versión GNU de basename El comando base</Descripción>
<ID>12</ID><Size>263987</Size><Creación>Fri Dec  8 10:21:26 2017</Creación><Descripción>Bash es un intérprete de un lenguaje de órdenes compatible con sh que ejecuta órdenes leídas desde la entrada estándar o desde un fichero Bash también incorpora características útiles tomadas de los s</Descripción>
<ID>13</ID><Size>1912</Size><Creación>Fri Dec  8 10:21:26 2017</Creación><Descripción>bashbug es un guión del shell para ayudar al usuario a componer y enviar por electrocorreo informes de fallos concernientes a bash, en un formato normalizado bashbug llama al editor especificado en la</Descripción>
<ID>14</ID><Size>7587</Size><Creación>Fri Dec  8 10:21:26 2017</Creación><Descripción>at y batch leen comandos desde la entrada estándar o un fichero especificado, los cuales van a ser ejecutados más tarde, utilizando read commands from standard input or a specified file which are to b</Descripción>
<ID>15</ID><Size>43178</Size><Creación>Fri Dec  8 10:21:26 2017</Creación><Descripción>bc es un lenguaje que permite la ejecución interactiva de sentencias con precisión numérica arbitraria La sintaxis es similar a la del lenguaje de programación C Se puede disponer de una biblioteca ma</Descripción>
<ID>16</ID><Size>730</Size><Creación>Fri Dec  8 10:21:26 2017</Creación><Descripción>--NO POSEE DESCRIPCIÓN--</Descripción>
<ID>17</ID><Size>19974</Size><Creación>Fri Dec  8 10:21:26 2017</Creación><Descripción>bzip2 comprime ficheros utilizando el algoritmo de compresión de texto por ordenación de bloques de Burrows- Wheeler Generalmente, la compresión obtenida es considerablemente mejor que la de compresor</Descripción>
<ID>18</ID><Size>19974</Size><Creación>Fri Dec  8 10:21:26 2017</Creación><Descripción>bzip2 comprime ficheros utilizando el algoritmo de compresión de texto por ordenación de bloques de Burrows- Wheeler Generalmente, la compresión obtenida es considerablemente mejor que la de compresor</Descripción>
<ID>19</ID><Size>19974</Size><Creación>Fri Dec  8 10:21:26 2017</Creación><Descripción>bzip2 comprime ficheros utilizando el algoritmo de compresión de texto por ordenación de bloques de Burrows- Wheeler Generalmente, la compresión obtenida es considerablemente mejor que la de compresor</Descripción>
<ID>20</ID><Size>3905</Size><Creación>Fri Dec  8 10:21:26 2017</Creación><Descripción>El lenguaje C++ proporciona sobrecarga de funciones, lo que significa que uno puede escribir varias funciones con el mismo nombre (siempre que la lista de argumentos de cada una sea distinta) Todos lo</Descripción>
<ID>21</ID><Size>6102</Size><Creación>Fri Dec  8 10:21:26 2017</Creación><Descripción>cdp es un programa interactivo en modo texto para reproducir CDs de audio bajo Linux Se basa en WorkBone, que a su vez se basa en los módulos "hardware.c", "database.c" y "struct.c" del avanzado repro</Descripción>
<ID>22</ID><Size>2559</Size><Creación>Fri Dec  8 10:21:26 2017</Creación><Descripción>chgrp cambia el grupo al que pertenece cada fichero dado a grupo, que puede ser bien un nombre de grupo o bien un identificador de grupo numérico (GID) OPCIONES DE POSIX -R Cambia recursivamente el gr</Descripción>
<ID>23</ID><Size>7473</Size><Creación>Fri Dec  8 10:21:26 2017</Creación><Descripción>chmod cambia los permisos de cada fichero dado según modo, que puede ser o bien una representación simbolica de los cambios a realizar, o bien un número octal que representa el patrón de bits de los n</Descripción>
<ID>24</ID><Size>3716</Size><Creación>Fri Dec  8 10:21:26 2017</Creación><Descripción>chown cambia el propietario de cada fichero, usuario o grupo, según el primer argumento que no sea una opción, el cual se interpreta como sigue Si sólo se da un nombre de usuario (o UID numérico), ent</Descripción>
<ID>25</ID><Size>1242</Size><Creación>Fri Dec  8 10:21:26 2017</Creación><Descripción>Esta documentación no será mantenida y puede ser inexacta o incompleta La documentación Texinfo es ahora la fuente autorizada Esta página de manual documenta la versión GNU de chroot chroot ejecuta un</Descripción>
<ID>26</ID><Size>605</Size><Creación>Fri Dec  8 10:21:26 2017</Creación><Descripción>La orden chvt N hace que /dev/ttyN sea la terminal en uso (La pantalla correspondiente se crea si no existía aún Para deshacerse de VTs que no se usan, emplee deallocvt(1).) La combinación de teclas (</Descripción>
<ID>27</ID><Size>797</Size><Creación>Fri Dec  8 10:21:26 2017</Creación><Descripción>Colrm elimina las columnas seleccionadas de un fichero La entrada se obtiene de la entrada estándar La salida se manda a la salida estándar Si se llama con un único parámetro, las columnas de cada lín</Descripción>
<ID>28</ID><Size>1641</Size><Creación>Fri Dec  8 10:21:26 2017</Creación><Descripción>La utilidad column formatea su entrada en múltiples columnas Las filas se rellenan antes que las columnas La entrada se toma de un fichero de operandos, o, por defecto, de la entrada estándar Las líne</Descripción>
<ID>29</ID><Size>13263</Size><Creación>Fri Dec  8 10:21:26 2017</Creación><Descripción>cp copia ficheros (o, opcionalmente, directorios) Uno puede bien copiar un fichero a un destino dado, o copiar arbitrariamente varios ficheros a un directorio destino Si el último argumento se refiere</Descripción>
<ID>30</ID><Size>17361</Size><Creación>Fri Dec  8 10:21:26 2017</Creación><Descripción>Esta página del Manual documenta la versión de GNU de cpio cpio copia ficheros en o desde un archivo tar o cpio, que es un fichero que contiene otros ficheros más información sobre ellos, como sus nom</Descripción>
<ID>31</ID><Size>6481</Size><Creación>Fri Dec  8 10:21:26 2017</Creación><Descripción>dd copia un fichero (de la entrada estándar a la salida estándar, por omisión) con un tamaño de bloque seleccionable por el usuario, a la par que, opcionalmente, realiza sobre él ciertas conversiones </Descripción>
<ID>32</ID><Size>4339</Size><Creación>Fri Dec  8 10:21:26 2017</Creación><Descripción>ddate escribe la fecha en formato de fecha Chiquitistaní Si es llamado sin argumentos, ddate cogerá la fecha actual del sistema, la convertirá al formato Chiquitistaní y la imprimirá en la salida está</Descripción>
<ID>33</ID><Size>768</Size><Creación>Fri Dec  8 10:21:26 2017</Creación><Descripción>El programa deallocvt libera memoria y estructuras de datos del núcleo para todas las consolas virtuales que no se usen Si se da un argumento N, solamente se desasigna /dev/ttyN Una consola virtual se</Descripción>
<ID>34</ID><Size>7501</Size><Creación>Fri Dec  8 10:21:26 2017</Creación><Descripción>df informa de la cantidad de espacio de disco usada y de la disponible en sistemas de ficheros Sin argumentos, df informa del espacio usado y del disponible en todos los sistemas de ficheros montados </Descripción>
<ID>35</ID><Size>14631</Size><Creación>Fri Dec  8 10:21:26 2017</Creación><Descripción>En el caso más simple, diff compara los contenidos de los dos ficheros fichero-origen y fichero-destino Un nombre de fichero - significa texto leído desde la entrada estándar Como un caso especial, di</Descripción>
<ID>36</ID><Size>3347</Size><Creación>Fri Dec  8 10:21:26 2017</Creación><Descripción>dircolors saca en la salida estándar una secuencia de órdenes del `shell' para definir los colores de salida deseados de ls (y dir, etc.) Modo de empleo normal: eval `dircolors [OPCIÓN] [FICHERO]` Si </Descripción>
<ID>37</ID><Size>1056</Size><Creación>Fri Dec  8 10:21:26 2017</Creación><Descripción>Esta documentación no será mantenida y puede ser inexacta o incompleta La documentación Texinfo es ahora la fuente autorizada Esta página de manual documenta la versión GNU de dirname dirname imprime </Descripción>
<ID>38</ID><Size>5516</Size><Creación>Fri Dec  8 10:21:26 2017</Creación><Descripción>Hostname es el programa que se utiliza para mostrar o establecer el nombre actual del sistema Muchos de los programas de trabajo en red usan este nombre para identificar a la máquina El NIS/YP también</Descripción>
<ID>39</ID><Size>5516</Size><Creación>Fri Dec  8 10:21:26 2017</Creación><Descripción>Hostname es el programa que se utiliza para mostrar o establecer el nombre actual del sistema Muchos de los programas de trabajo en red usan este nombre para identificar a la máquina El NIS/YP también</Descripción>
<ID>40</ID><Size>5564</Size><Creación>Fri Dec  8 10:21:27 2017</Creación><Descripción>du informa de la cantidad de espacio de disco usada por los ficheros especificados, y por cada directorio en las jerarquías cuyas raíces estén en los ficheros especificados Aquí, `espacio de disco usa</Descripción>
<ID>41</ID><Size>8887</Size><Creación>Fri Dec  8 10:21:27 2017</Creación><Descripción>dumpkeys escribe, en la salida estándar, los contenidos actuales de las tablas de traducción del controlador de teclado, en el formato especificado por keymaps(5) Mediante el empleo de varias opciones</Descripción>
<ID>42</ID><Size>1955</Size><Creación>Fri Dec  8 10:21:27 2017</Creación><Descripción>Esta documentación ha dejado de mantenerse y puede ser inexacta o estar incompleta La documentación Texinfo es ahora la fuente autorizada Esta página de manual documenta la versión GNU de echo Tenga e</Descripción>
<ID>43</ID><Size>14618</Size><Creación>Fri Dec  8 10:21:27 2017</Creación><Descripción>Grep busca en la entrada, bien en la que se le especifica con nombres de ficheros o bien en la entrada estándar si no se le dan dichos nombres o si uno de éstos consiste en -, líneas que concuerden o </Descripción>
<ID>44</ID><Size>2093</Size><Creación>Fri Dec  8 10:21:27 2017</Creación><Descripción>Esta documentación ha dejado de mantenerse y puede ser inexacta o estar incompleta La documentación Texinfo es ahora la fuente autorizada Esta página de manual documenta la versión GNU de env env ejec</Descripción>
<ID>45</ID><Size>1914</Size><Creación>Fri Dec  8 10:21:27 2017</Creación><Descripción>Epsffit encaja un fichero EPSF (PostScript encapsulado) en una caja de tamaño determinado Las coordenadas de la caja se especifican con (llx,lly) para la esquina inferior izquierda, y (urx,ury) para l</Descripción>
<ID>46</ID><Size>5033</Size><Creación>Fri Dec  8 10:21:27 2017</Creación><Descripción>Esta documentación no será mantenida y puede ser inexacta o incompleta La documentación Texinfo es ahora la fuente autorizada Esta página de manual documenta la versión GNU de expr expr evalúa una exp</Descripción>
<ID>47</ID><Size>1808</Size><Creación>Fri Dec  8 10:21:27 2017</Creación><Descripción>Extractres extrae recursos (fuentes, procsets, patrones, ficheros, etc) que aparecen en un documento PostScript, e inserta los comentarios %%IncludeResource apropiados en el prólogo del documento Los </Descripción>
<ID>48</ID><Size>1094</Size><Creación>Fri Dec  8 10:21:27 2017</Creación><Descripción>Esta documentación no será mantenida y puede ser inexacta o incompleta La documentación Texinfo es ahora la fuente autorizada Esta página de manual documenta la versión GNU de false (y probablemente c</Descripción>
<ID>49</ID><Size>14618</Size><Creación>Fri Dec  8 10:21:27 2017</Creación><Descripción>Grep busca en la entrada, bien en la que se le especifica con nombres de ficheros o bien en la entrada estándar si no se le dan dichos nombres o si uno de éstos consiste en -, líneas que concuerden o </Descripción>
<ID>50</ID><Size>16570</Size><Creación>Fri Dec  8 10:21:27 2017</Creación><Descripción>Esta página del Manual documenta la versión 3.26 de la orden file File comprueba cada argumento en un intento de clasificarlo Hay tres conjuntos de pruebas, efectuadas en este orden: pruebas de sistem</Descripción>
<ID>51</ID><Size>24733</Size><Creación>Fri Dec  8 10:21:27 2017</Creación><Descripción>Esta página del Manual documenta la versión de GNU de find find recorre el árbol de directorio cuya raíz reside en cada nombre de fichero dado, evaluando de izquierda a derecha la expresión especifica</Descripción>
<ID>52</ID><Size>1009</Size><Creación>Fri Dec  8 10:21:27 2017</Creación><Descripción>Fixdlsrps es un filtro perl que "prepara" el PostScript generado por el manejador de DviLaser/PS para que funcione correctamente con el paquete psutils de Angus Duggan AUTOR Copyright (C) Angus J C Du</Descripción>
<ID>53</ID><Size>991</Size><Creación>Fri Dec  8 10:21:27 2017</Creación><Descripción>Fixfmps es un filtro perl que "prepara" el PostScript generado por Framemaker para que funcione correctamente con el paquete psutils de Angus Duggan AUTOR Copyright (C) Angus J C Duggan 1991-1995 VÉAS</Descripción>
<ID>54</ID><Size>1131</Size><Creación>Fri Dec  8 10:21:27 2017</Creación><Descripción>Fixmacps es un filtro perl que "prepara" el PostScript generado por un PC Macintosh para que funcione correctamente con el paquete psutils de Angus Duggan FICHEROS /usr/lib/psutils/md68_0.ps, /usr/lib</Descripción>
<ID>55</ID><Size>1073</Size><Creación>Fri Dec  8 10:21:27 2017</Creación><Descripción>Fixpsditps es un filtro perl que "arregla" el PostScript generado por el programa psdit de Transcript para que funcione correctamente con el paquete psutils de Angus Duggan AUTOR Copyright (C) Angus J</Descripción>
<ID>56</ID><Size>994</Size><Creación>Fri Dec  8 10:21:27 2017</Creación><Descripción>Fixpspps es un filtro perl que "prepara" el PostScript generado por PSPrint para que funcione correctamente con el paquete psutils de Angus Duggan AUTOR Copyright (C) Angus J C Duggan 1991-1995 VÉASE </Descripción>
<ID>57</ID><Size>988</Size><Creación>Fri Dec  8 10:21:27 2017</Creación><Descripción>Fixscribeps es un filtro perl que "prepara" PostScript generado por Scribe para que funcione correctamente con el paquete psutils de Angus Duggan AUTOR Copyright (C) Angus J C Duggan 1991-1995 VÉASE T</Descripción>
<ID>58</ID><Size>1026</Size><Creación>Fri Dec  8 10:21:27 2017</Creación><Descripción>--NO POSEE DESCRIPCIÓN--</Descripción>
<ID>59</ID><Size>1026</Size><Creación>Fri Dec  8 10:21:27 2017</Creación><Descripción>Fixwfwps es un filtro perl que "prepara" el PostScript generado por el Word para Windows para que funcione correctamente con el paquete psutils de Angus Duggan AUTOR Copyright (C) Angus J C Duggan 199</Descripción>
<ID>60</ID><Size>997</Size><Creación>Fri Dec  8 10:21:27 2017</Creación><Descripción>Fixwpps es un flitro perl que "prepara" el PostScript generado por WordPerfect 5.0 and 5.1 para que funcione correctamente con el paquete psutils de Angus Duggan AUTOR Copyright (C) Angus J C Duggan 1</Descripción>
<ID>61</ID><Size>986</Size><Creación>Fri Dec  8 10:21:27 2017</Creación><Descripción>Fixwwps es un filtro perl que "prepara" el PostScript del Windows Write para que funcione correctamente con el paquete psutils de Angus Duggan AUTOR Copyright (C) Angus J C Duggan 1991-1995 VÉASE TAMB</Descripción>
<ID>62</ID><Size>141841</Size><Creación>Fri Dec  8 10:21:27 2017</Creación><Descripción>flex es una herramienta para generar escáneres: programas que reconocen patrones léxicos en un texto flex lee los ficheros de entrada dados, o la entrada estándar si no se le ha indicado ningún nombre</Descripción>
<ID>63</ID><Size>141841</Size><Creación>Fri Dec  8 10:21:27 2017</Creación><Descripción>flex es una herramienta para generar escáneres: programas que reconocen patrones léxicos en un texto flex lee los ficheros de entrada dados, o la entrada estándar si no se le ha indicado ningún nombre</Descripción>
<ID>64</ID><Size>14660</Size><Creación>Fri Dec  8 10:21:27 2017</Creación><Descripción>formail es un filtro que se puede usar para forzar correo en un formato de buzón, proteger `From', generar cabeceras de autorespuesta, hacer simples transformaciones/extracciones o dividir un fichero </Descripción>
<ID>65</ID><Size>1611</Size><Creación>Fri Dec  8 10:21:27 2017</Creación><Descripción>free muestra la cantidad total de memoria fisica y de intercambio presente en el sistema, asi como la memoria compartida y los buffers usados por el nucleo Opciones El modificador -b muestra la cantid</Descripción>
<ID>66</ID><Size>78360</Size><Creación>Fri Dec  8 10:21:27 2017</Creación><Descripción>Gawk es la implementación del Proyecto GNU del lenguaje de programación AWK Está conforme con la definición del lenguaje en el POSIX 1003.2 Command Language And Utilities Standard Esta versión está ba</Descripción>
<ID>67</ID><Size>9665</Size><Creación>Fri Dec  8 10:21:27 2017</Creación><Descripción>El proposito de un depurador como GDB es permitir al usuario ver lo que está ocurriendo ``dentro'' de otro programa mientras que se está ejecutando -- o lo que estaba haciendo en el momento que falló </Descripción>
<ID>68</ID><Size>1227</Size><Creación>Fri Dec  8 10:21:27 2017</Creación><Descripción>Getafm genera un archivo PostScript que imprime un fichero AFM para una fuente dada al canal de salida de la impresora La salida de getafm debería ser enviada a una impresora, o a GhostScript Por ejem</Descripción>
<ID>69</ID><Size>17484</Size><Creación>Fri Dec  8 10:21:27 2017</Creación><Descripción>getopt se usa para partir (analizar) las opciones de las líneas de comandos para un fácil análisis por parte de los procedimientos del shell, y para identificar las opciones legales Usa las rutinas ge</Descripción>
<ID>70</ID><Size>8569</Size><Creación>Fri Dec  8 10:21:27 2017</Creación><Descripción>gprof produce un perfil de ejecución de programas en C, Pascal o FORTRAN77 El efecto de las rutinas llamadas se incorpora en el perfil de cada llamador Los datos del perfil se toman del fichero de per</Descripción>
<ID>71</ID><Size>14618</Size><Creación>Fri Dec  8 10:21:27 2017</Creación><Descripción>Grep busca en la entrada, bien en la que se le especifica con nombres de ficheros o bien en la entrada estándar si no se le dan dichos nombres o si uno de éstos consiste en -, líneas que concuerden o </Descripción>
<ID>72</ID><Size>1299</Size><Creación>Fri Dec  8 10:21:28 2017</Creación><Descripción>Esta documentación no será mantenida y puede ser inexacta o incompleta La documentación Texinfo es ahora la fuente autorizada Esta página de manual documenta la versión GNU de groups groups imprime lo</Descripción>
<ID>73</ID><Size>19258</Size><Creación>Fri Dec  8 10:21:28 2017</Creación><Descripción>El programa gzip reduce el tamaño de los ficheros dados mediante el algoritmo de compresión de Lempel-Ziv (LZ77) Cuando es posible, cada fichero se reemplaza por otro con la extensión .gz, manteniéndo</Descripción>
<ID>74</ID><Size>1850</Size><Creación>Fri Dec  8 10:21:28 2017</Creación><Descripción>La utilidad gzexe nos permite comprimir un programa ejecutable dejando el fichero comprimido con el mismo nombre, de forma que al ejecutarlo se descomprima automáticamente y se ejecute el programa ori</Descripción>
<ID>75</ID><Size>19258</Size><Creación>Fri Dec  8 10:21:28 2017</Creación><Descripción>El programa gzip reduce el tamaño de los ficheros dados mediante el algoritmo de compresión de Lempel-Ziv (LZ77) Cuando es posible, cada fichero se reemplaza por otro con la extensión .gz, manteniéndo</Descripción>
<ID>76</ID><Size>5516</Size><Creación>Fri Dec  8 10:21:28 2017</Creación><Descripción>Hostname es el programa que se utiliza para mostrar o establecer el nombre actual del sistema Muchos de los programas de trabajo en red usan este nombre para identificar a la máquina El NIS/YP también</Descripción>
<ID>77</ID><Size>2136</Size><Creación>Fri Dec  8 10:21:28 2017</Creación><Descripción>--NO POSEE DESCRIPCIÓN--</Descripción>
<ID>78</ID><Size>1977</Size><Creación>Fri Dec  8 10:21:28 2017</Creación><Descripción>Esta documentación no será mantenida y puede ser inexacta o incompleta La documentación Texinfo es ahora la fuente autorizada Esta página de manual documenta la versión GNU de id id imprime informació</Descripción>
<ID>79</ID><Size>1380</Size><Creación>Fri Dec  8 10:21:28 2017</Creación><Descripción>Igawk es un simple script de shell que añade la capacidad de tener ``ficheros de inclusión'' con gawk(1) Los programas AWK para igawk son los mismos que para gawk, con la única excepción de que puede </Descripción>
<ID>80</ID><Size>1699</Size><Creación>Fri Dec  8 10:21:28 2017</Creación><Descripción>Includeres incluye recursos (fuentes, procsets, patrones, ficheros, etc) en el lugar de los comentarios %%IncludeResource en un documento PostScript Los recursos se buscan en el directorio actual y en</Descripción>
<ID>81</ID><Size>6670</Size><Creación>Fri Dec  8 10:21:28 2017</Creación><Descripción>install copia ficheros y establece sus modos de acceso y, si es posible, sus propietario y grupo En la primera de las formas de empleo mencionadas antes, el fichero origen se copia al fichero objetivo</Descripción>
<ID>82</ID><Size>498</Size><Creación>Fri Dec  8 10:21:28 2017</Creación><Descripción>Este capítulo describe órdenes de usuario AUTORES Busque en la cabecera de cada página del Manual el autor o autores y las condiciones sobre los derechos de copia ¡Observe que éstos pueden ser diferen</Descripción>
<ID>83</ID><Size>1539</Size><Creación>Fri Dec  8 10:21:28 2017</Creación><Descripción>Sin argumentos, kbd_mode muestra el modo actual de teclado (RAW, MEDIUMRAW o XLATE) Con un argumento, establece el modo del teclado según se indica: -s: modo de código de rastreo (RAW, CRUDO), -k: mod</Descripción>
<ID>84</ID><Size>2800</Size><Creación>Fri Dec  8 10:21:28 2017</Creación><Descripción>Last Busca a través del archivo /var/log/wtmp (o el archivo indicado por la bandera -f) e imprime una lista de todos los usuarios conectados (y desconectados) desde que el fichero fue creado Pueden in</Descripción>
<ID>85</ID><Size>2800</Size><Creación>Fri Dec  8 10:21:28 2017</Creación><Descripción>Last Busca a través del archivo /var/log/wtmp (o el archivo indicado por la bandera -f) e imprime una lista de todos los usuarios conectados (y desconectados) desde que el fichero fue creado Pueden in</Descripción>
<ID>86</ID><Size>34174</Size><Creación>Fri Dec  8 10:21:28 2017</Creación><Descripción>ld combina un número de ficheros objeto y archivos, reubica sus datos y enlaza referencias de símbolos A menudo el último paso en el proceso de construcción de un nuevo programa compilado para su ejec</Descripción>
<ID>87</ID><Size>141841</Size><Creación>Fri Dec  8 10:21:28 2017</Creación><Descripción>flex es una herramienta para generar escáneres: programas que reconocen patrones léxicos en un texto flex lee los ficheros de entrada dados, o la entrada estándar si no se le ha indicado ningún nombre</Descripción>
<ID>88</ID><Size>9496</Size><Creación>Fri Dec  8 10:21:28 2017</Creación><Descripción>Hay en Unix dos conceptos de `enlace', llamados usualmente enlace duro (o físico) y enlace blando (o simbólico) Un enlace duro es simplemente un nombre para un fichero (Y un fichero puede tener varios</Descripción>
<ID>89</ID><Size>8167</Size><Creación>Fri Dec  8 10:21:28 2017</Creación><Descripción>lockfile Se puede usar para crear uno o más ficheros semáforo Si lockfile no puede crear todos los ficheros especificados (en el orden especificado), espera tiempodormido segundos (por defecto 8) y re</Descripción>
<ID>90</ID><Size>13035</Size><Creación>Fri Dec  8 10:21:28 2017</Creación><Descripción>login es usado cuando se firma en un sistema Puede ser usado para cambiar desde un usuario a otro en cualquier momento (los shells más modernos disponen de esta característica incluida internamente) S</Descripción>
<ID>91</ID><Size>1116</Size><Creación>Fri Dec  8 10:21:28 2017</Creación><Descripción>Esta documentación no va a ser mantenida a partir de ahora y puede ser inexacta o incompleta La documentación Texinfo es ahora la fuente autorizada Esta página de manual documenta la versión de GNU de</Descripción>
<ID>92</ID><Size>1678</Size><Creación>Fri Dec  8 10:21:28 2017</Creación><Descripción>La utilidad look muestra las líneas del fichero file que contienen string como prefijo Dado que look realiza una búsqueda binaria, las líneas en file deben estar ordenadas Si no se especifica file, se</Descripción>
<ID>93</ID><Size>20101</Size><Creación>Fri Dec  8 10:21:28 2017</Creación><Descripción>El programa ls lista primero sus argumentos no directorios fichero, y luego para cada argumento directorio todos los ficheros susceptibles de listarse contenidos en dicho directorio Si no hay presente</Descripción>
<ID>94</ID><Size>11374</Size><Creación>Fri Dec  8 10:21:28 2017</Creación><Descripción>El propósito de la utilidad make es determinar automáticamente qué piezas de un programa necesitan ser recompiladas, y lanzar las órdenes para recompilarlas Este manual describe la implementación de m</Descripción>
<ID>95</ID><Size>7866</Size><Creación>Fri Dec  8 10:21:28 2017</Creación><Descripción>man formata y muestra las páginas del manual `en-linea' Esta versión reconoce las variables de ambiente (environment) MANPATH y (MAN)PAGER (vea más lejos) Si la sección es indicada, man busca solament</Descripción>
<ID>96</ID><Size>2786</Size><Creación>Fri Dec  8 10:21:28 2017</Creación><Descripción>Mattrib se usa para cambiar los atributos de un fichero de MS-DOS Tiene la siguiente sintaxis: mattrib [-a|+a] [-h|+h] [-r|+r] [-s|+s] ficheromsdos [ ficherosmsdos ] Mattrib añade atributos a un fiche</Descripción>
<ID>97</ID><Size>2605</Size><Creación>Fri Dec  8 10:21:28 2017</Creación><Descripción>El comando mbadblocks se usa para explorar un disquete MS- DOS y marcar sus bloques erroneos sin usar como defectuosos Usa la siguiente sintaxis: mbadblocks unidad: Mbadblocks explora un disquete MS-D</Descripción>
<ID>98</ID><Size>132253</Size><Creación>Fri Dec  8 10:21:28 2017</Creación><Descripción>Midnight Commander es un navegador de directorios/gestor de ficheros para sistemas operativos tipo Unix OPCIONES -a Deshabilita el uso de caracteres gráficos para el dibujo de líneas -b Fuerza el uso </Descripción>
<ID>99</ID><Size>2942</Size><Creación>Fri Dec  8 10:21:28 2017</Creación><Descripción>El comando mcd se utiliza para cambiar el directorio de trabajo de las mtools en el disco MSDOS La sintaxis es la siguiente: mcd [directorio_msdos] Sin argumentos, mcd informa de la unidad activa y de</Descripción>
<ID>100</ID><Size>4341</Size><Creación>Fri Dec  8 10:21:29 2017</Creación><Descripción>El comando mcopy se utiliza para copiar ficheros MS-DOS a y desde Unix La sintaxis es la siguiente: mcopy [-tnvmoOsSrRA] fichero_origen fichero_destino mcopy [-tnvmoOsSrRA] fichero_origen [ficheros_or</Descripción>
<ID>101</ID><Size>2127</Size><Creación>Fri Dec  8 10:21:29 2017</Creación><Descripción>El comando mdel se utiliza para borrar un fichero MS-DOS Su sintaxis es: mdel [-v] ficheromsdos [ ficherosmsdos ] Mdel borra ficheros en un sistema de ficheros MS-DOS Mdel solicita verificación antes </Descripción>
<ID>102</ID><Size>2224</Size><Creación>Fri Dec  8 10:21:29 2017</Creación><Descripción>El comando mdeltree se utiliza para borrar un fichero MS- DOS Su sintaxis es: mdeltree [-v] directoriomsdos [directoriosmsdos ] Mdeltree elimina un directorio y todos los ficheros y subdirectorios que</Descripción>
<ID>103</ID><Size>2935</Size><Creación>Fri Dec  8 10:21:29 2017</Creación><Descripción>El comando mdir es usado para ver un directorio MS-DOS Su síntaxis es: mdir [-w] directorio-msdos mdir [-f] [-w] [-a]fichero-msdos [ ficheros-msdosfR ] Mdir lista los contenidos de directorios MS-DOS </Descripción>
<ID>104</ID><Size>783</Size><Creación>Fri Dec  8 10:21:29 2017</Creación><Descripción>Mesg controla el acceso a tu terminal por otros Generalmente es usado para permitir o negar a otros usuarios la escritura en el terminal (vea write(1)) OPCIONES y Permite el acceso a escritura al term</Descripción>
<ID>105</ID><Size>5202</Size><Creación>Fri Dec  8 10:21:29 2017</Creación><Descripción>El programa ``mev'' es parte del paquete gpm La información de más abajo está extraída del fichero texinfo, la cual es la fuente de información preferida El programa mev se ha realizado tomando como m</Descripción>
<ID>106</ID><Size>6770</Size><Creación>Fri Dec  8 10:21:29 2017</Creación><Descripción>El comando mformat se usa para incluir un sistema de ficheros MS-DOS en un diskette formateado a bajo nivel Su síntaxis es: mformat [-t cilindros] [-hcabezas] [-s sectores] [-l etiqueta de volumen] [-</Descripción>
<ID>107</ID><Size>2341</Size><Creación>Fri Dec  8 10:21:29 2017</Creación><Descripción>mkdir crea directorios con los nombres especificados De forma predeterminada, los permisos de los directorios creados son 0777 (`a+rwx') menos los bits puestos a 1 en la umask OPCIONES -m modo, --mode</Descripción>
<ID>108</ID><Size>2098</Size><Creación>Fri Dec  8 10:21:29 2017</Creación><Descripción>mkfifo crea FIFOs (también llamados "tuberías con nombre") con los nombres de fichero especificados Un "FIFO" es un tipo de fichero especial que permite a procesos independientes comunicarse Un proces</Descripción>
<ID>109</ID><Size>4350</Size><Creación>Fri Dec  8 10:21:29 2017</Creación><Descripción>mknod crea un FIFO (tubería con nombre), un fichero especial de bloques, o un fichero especial de caracteres, con el nombre especificado Un fichero especial es una tripleta (booleano, entero, entero) </Descripción>
<ID>110</ID><Size>2420</Size><Creación>Fri Dec  8 10:21:29 2017</Creación><Descripción>El comando mmount se usa para montar discos MS-DOS Solo está disponible en Linux, ya que solo es útil si el núcleo del SO permite configurar la geometría del disco Su sintáxis es: mmount unidadmsdos [</Descripción>
<ID>111</ID><Size>5563</Size><Creación>Fri Dec  8 10:21:29 2017</Creación><Descripción>More es un filtro para paginar texto, mostrando una pantalla cada vez Esta versión es especialmente primitiva Los usarios deben tener en cuenta que less(1) ("menos") provee more(1) ("más") emulación y</Descripción>
<ID>112</ID><Size>2143</Size><Creación>Fri Dec  8 10:21:29 2017</Creación><Descripción>El comando mrd se usa para borrar subdirectorios de MS- DOS Su sintáxis es: mrd [-v] directoriomsdos [directoriosmsdos ] Mrd borra un directorio de un sistema de ficheros MS-DOS Si el directorio no ex</Descripción>
<ID>113</ID><Size>1788</Size><Creación>Fri Dec  8 10:21:29 2017</Creación><Descripción>--NO POSEE DESCRIPCIÓN--</Descripción>
<ID>114</ID><Size>2613</Size><Creación>Fri Dec  8 10:21:29 2017</Creación><Descripción>El comando mren se usa para renombrar o mover un fichero o subdirectorio existente de MS-DOS Su sintaxis es: mren [-voOsSrRA] ficheroorigen ficherodestino Mren renombra un fichero existente en un sist</Descripción>
<ID>115</ID><Size>4528</Size><Creación>Fri Dec  8 10:21:29 2017</Creación><Descripción>Esta página del Manual documenta la versión de GNU de mt mt realiza la operación dada, que debe ser una de las operaciones de cinta listadas más abajo, sobre una unidad de cinta magnética El dispositi</Descripción>
<ID>116</ID><Size>90981</Size><Creación>Fri Dec  8 10:21:29 2017</Creación><Descripción>--NO POSEE DESCRIPCIÓN--</Descripción>
<ID>117</ID><Size>2420</Size><Creación>Fri Dec  8 10:21:29 2017</Creación><Descripción>El comando mtoolstest se usa para comprobar los ficheros de configuración Para llamarlo, simplemente teclee mtoolstest sin ningún argumento Mtoolstest lee los ficheros de configuración de mtools y mue</Descripción>
<ID>118</ID><Size>2823</Size><Creación>Fri Dec  8 10:21:29 2017</Creación><Descripción>El comando mtype se usa para mostrar los contenidos de los ficheros MSDOS Su sintaxis es: mtype [-ts] ficheromsdos [ ficheromsdos ] .)l Mtype muestra el fichero MS-DOS indicado en la pantalla Además d</Descripción>
<ID>119</ID><Size>6684</Size><Creación>Fri Dec  8 10:21:29 2017</Creación><Descripción>mv mueve o renombra ficheros o directorios Si el último argumento nombra a un directorio existente, mv mueve cada uno de los otros ficheros a un fichero con el mismo nombre en ese directorio Si no, si</Descripción>
<ID>120</ID><Size>3812</Size><Creación>Fri Dec  8 10:21:29 2017</Creación><Descripción>El comando mzip se usa para dar comandos específicos de los discos Zip bajo Solaris o HPUX Su sintáxis es: mzip [-epqrwx] Mzip permite las siguientes opciones en la línea de comandos: e Expulsa el dis</Descripción>
<ID>121</ID><Size>2143</Size><Creación>Fri Dec  8 10:21:29 2017</Creación><Descripción>Namei usa sus argumentos como trayectorias hacia cualquier tipo de fichero Unix (enlaces simbólicos, ficheros, directorios, y el resto) Namei a continuación sigue cada trayectoria hasta encontrar un p</Descripción>
<ID>122</ID><Size>875</Size><Creación>Fri Dec  8 10:21:29 2017</Creación><Descripción>Newgrp cambia la identificación de grupo de su invocador, análogamente a login(1) La misma persona queda ingresada, y el directorio actual no es modificado, pero los cálculos de los permisos de acceso</Descripción>
<ID>123</ID><Size>1736</Size><Creación>Fri Dec  8 10:21:29 2017</Creación><Descripción>Esta documentación no va a ser mantenida a partir de ahora y puede ser inexacta o incompleta La documentación Texinfo es ahora la fuente autorizada Esta página de manual documenta la versión de GNU de</Descripción>
<ID>124</ID><Size>5516</Size><Creación>Fri Dec  8 10:21:29 2017</Creación><Descripción>Hostname es el programa que se utiliza para mostrar o establecer el nombre actual del sistema Muchos de los programas de trabajo en red usan este nombre para identificar a la máquina El NIS/YP también</Descripción>
<ID>125</ID><Size>3434</Size><Creación>Fri Dec  8 10:21:29 2017</Creación><Descripción>nlmconv convierte el fichero objeto reubicable fichent al Módulo Cargable de Netware fichsal, leyendo opcionalmente fichcab para obtener información de cabecera NLM Para instrucciones sobre cómo escri</Descripción>
<ID>126</ID><Size>6452</Size><Creación>Fri Dec  8 10:21:29 2017</Creación><Descripción>GNU nm lista los símbolos de los ficheros objeto fichobj Si no se da ninguno como argumento, nm supone `a.out' OPCIONES Las formas larga y corta de las opciones, mostradas aquí como alternativas, son </Descripción>
<ID>127</ID><Size>1982</Size><Creación>Fri Dec  8 10:21:29 2017</Creación><Descripción>Esta documentación no va a ser mantenida a partir de ahora y puede ser inexacta o incompleta La documentación Texinfo es ahora la fuente autorizada Esta página de manual documenta la versión de GNU de</Descripción>
<ID>128</ID><Size>13695</Size><Creación>Fri Dec  8 10:21:29 2017</Creación><Descripción>El programa de utilidad de GNU objcopy copia los contenidos de un fichero objeto a otro objcopy emplea la Biblioteca BFD de GNU para leer y escribir los ficheros objeto Puede escribir el fichero objet</Descripción>
<ID>129</ID><Size>11397</Size><Creación>Fri Dec  8 10:21:29 2017</Creación><Descripción>objdump despliega información sobre uno o más ficheros objeto Las opciones controlan qué información mostrar en particular Esta información es útil mayormente para programadores que estén trabajando e</Descripción>
<ID>130</ID><Size>774</Size><Creación>Fri Dec  8 10:21:29 2017</Creación><Descripción>Odha sido desaprobado para favorecer a hexdump(1) Hexdump,si es llamado como od,proporciona compatibilidad para las opciones arriba mencionadas No existe compatibilidad para la opción -s(ver strings(1</Descripción>
<ID>131</ID><Size>4743</Size><Creación>Fri Dec  8 10:21:29 2017</Creación><Descripción>Cuando se utiliza sin parámetros passwd cambia la contraseña para el usuario que lo invoca Primero le exigirá la contraseña vigente, y a continuación pedirá dos veces la nueva para prevenir errores de</Descripción>
<ID>132</ID><Size>1710</Size><Creación>Fri Dec  8 10:21:29 2017</Creación><Descripción>Esta documentación no se mantendrá en el futuro y puede ser inexacta o incompleta La documentación en formato Texinfo es actualmente la fuente autorizada Esta página del manual documenta la versión GN</Descripción>
<ID>133</ID><Size>2064</Size><Creación>Fri Dec  8 10:21:29 2017</Creación><Descripción>Esta documentación no será mantenida y puede ser inexacta o incompleta La documentación Texinfo es ahora la fuente autorizada Esta página de manual documenta la versión GNU de pathchk Para cada ficher</Descripción>
<ID>134</ID><Size>9113</Size><Creación>Fri Dec  8 10:21:29 2017</Creación><Descripción>--NO POSEE DESCRIPCIÓN--</Descripción>
<ID>135</ID><Size>4505</Size><Creación>Fri Dec  8 10:21:29 2017</Creación><Descripción>--NO POSEE DESCRIPCIÓN--</Descripción>
<ID>136</ID><Size>16843</Size><Creación>Fri Dec  8 10:21:29 2017</Creación><Descripción>Pine es una herramienta de manejo de mensajes orientada a la pantalla En su configuración por defecto, Pine ofrece un conjunto de funciones intencionalmente limitado orientado al usuario novel, pero t</Descripción>
<ID>137</ID><Size>5605</Size><Creación>Fri Dec  8 10:21:30 2017</Creación><Descripción>Esta documentación no se mantendrá más y puede que sea inexacta o incompleta La documentación en formato Texinfo es la fuente autorizada Esta página del manual documenta la versión GNU de pr pr imprim</Descripción>
<ID>138</ID><Size>1275</Size><Creación>Fri Dec  8 10:21:30 2017</Creación><Descripción>Esta documentación no será mantenida y puede ser inexacta o incompleta La documentación Texinfo es ahora la fuente autorizada Esta página de manual documenta la versión GNU de printenv Si no se propor</Descripción>
<ID>139</ID><Size>1704</Size><Creación>Fri Dec  8 10:21:30 2017</Creación><Descripción>Esta documentación no será mantenida y puede ser inexacta o incompleta La documentación Texinfo es ahora la fuente autorizada Esta página de manual documenta la versión GNU de printf printf imprime la</Descripción>
<ID>140</ID><Size>37813</Size><Creación>Fri Dec  8 10:21:30 2017</Creación><Descripción>Para un comienzo rápido véase NOTAS al final Procmail se debería llamar automáticamente sobre el mecanismo del fichero .forward tan pronto como llegue el correo De forma alternativa, cuando se lo inst</Descripción>
<ID>141</ID><Size>13044</Size><Creación>Fri Dec  8 10:21:30 2017</Creación><Descripción>ps muestra una instantánea de los procesos actuales Si quiere una actualización contínua, use top Esta página de manual documenta (o por lo menos intenta documentar) la versión de ps basada en /proc O</Descripción>
<ID>142</ID><Size>1726</Size><Creación>Fri Dec  8 10:21:30 2017</Creación><Descripción>Psbook reordena las páginas de un documento PostScript en "pliegos" para imprimir libros o folletos, creando un nuevo fichero PostScript El fichero PostScript de entrada debe seguir los Convenios de E</Descripción>
<ID>143</ID><Size>1862</Size><Creación>Fri Dec  8 10:21:30 2017</Creación><Descripción>psfaddtable toma un tipo de letra de consola en formato .psf como el dado por fichero-de-tipos y lo mezcla con la tabla de caracteres Unicode dada en fichero-tabla para producir un fichero de tipos co</Descripción>
<ID>144</ID><Size>755</Size><Creación>Fri Dec  8 10:21:30 2017</Creación><Descripción>psfgettable extrae la tabla de caracteres Unicode empotrada de un tipo de letra de consola en formato .psf a un fichero ASCII legible por humanos en el formato empleado por psfaddtable(1) Si el nombre</Descripción>
<ID>145</ID><Size>812</Size><Creación>Fri Dec  8 10:21:30 2017</Creación><Descripción>psfstriptable lee un tipo de consola en formato .psf de fichero-de-tipos, o de la entrada estándar si fichero-de- tipos es un guión (-), que puede tener una tabla de tipos Unicode empotrada, y escribe</Descripción>
<ID>146</ID><Size>1535</Size><Creación>Fri Dec  8 10:21:30 2017</Creación><Descripción>--NO POSEE DESCRIPCIÓN--</Descripción>
<ID>147</ID><Size>5160</Size><Creación>Fri Dec  8 10:21:30 2017</Creación><Descripción>Psnup mete físicamente múltiples páginas lógicas en cada hoja de papel El fichero PostScript de entrada debe seguir los Convenios de Estructuración de Documentos de Adobe (Document Structuring Convent</Descripción>
<ID>148</ID><Size>2332</Size><Creación>Fri Dec  8 10:21:30 2017</Creación><Descripción>Psresize reescala y centra un documento en un tamaño de papel diferente El fichero PostScript de entrada debe seguir los Convenios de Estucturación de Documentos de Adobe (Document Structuring Convent</Descripción>
<ID>149</ID><Size>2835</Size><Creación>Fri Dec  8 10:21:30 2017</Creación><Descripción>Psselect selecciona páginas de un documento PostScript, creando un nuevo fichero PostScript El fichero de entrada PostScript debe seguir las Convenios de Estructuración de Documentos de Adobe (Adobe D</Descripción>
<ID>150</ID><Size>5271</Size><Creación>Fri Dec  8 10:21:30 2017</Creación><Descripción>Pstops reordena páginas de un documento PostScript, creando un nuevo fichero PostScript El fichero PostScript de entrada debe seguir los Convenios de Estructuración de Documentos de Adobe (Adobe Docum</Descripción>
<ID>151</ID><Size>1300</Size><Creación>Fri Dec  8 10:21:30 2017</Creación><Descripción>--NO POSEE DESCRIPCIÓN--</Descripción>
<ID>152</ID><Size>10903</Size><Creación>Fri Dec  8 10:21:30 2017</Creación><Descripción>Python es un lenguaje de programación orientado a objetos interactivo e interpretado que combina una considerable potencia con una sintaxis muy clara Vea la Guía de aprendizaje de Python para consegui</Descripción>
<ID>153</ID><Size>2204</Size><Creación>Fri Dec  8 10:21:30 2017</Creación><Descripción>ranlib genera un índice de los contenidos de un archivo, y lo almacena en el archivo El índice lista cada símbolo definido por cada miembro del archivo que sea un fichero objeto reubicable Se puede em</Descripción>
<ID>154</ID><Size>5495</Size><Creación>Fri Dec  8 10:21:30 2017</Creación><Descripción>El comando readprofile usa la información de /proc/profile para imprimir datos ASCII por la salida estándar La salida está organizada en tres columnas: la primera es el número de impulsos de reloj, la</Descripción>
<ID>155</ID><Size>986</Size><Creación>Fri Dec  8 10:21:30 2017</Creación><Descripción>reset llama a tput(1) con los argumentos clear,rmacs,rmm,rmul,rs1,rs2 y rs3 Esto provoca que tput envíe las cadenas de restauración al terminal basándose en la información de /etc/termcap (para el tpu</Descripción>
<ID>156</ID><Size>418</Size><Creación>Fri Dec  8 10:21:30 2017</Creación><Descripción>La utilidad rev copia los ficheros especificados a la salida estándar, invirtiendo el orden de los caracteres de cada línea Si no se especifican ficheros, se lee de la entrada estándar </Descripción>
<ID>157</ID><Size>4451</Size><Creación>Fri Dec  8 10:21:30 2017</Creación><Descripción>rm borra cada fichero dado Por lo normal, no borra directorios Pero cuando se da la opción -r o -R, se borra el árbol de directorios entero a partir del directorio especificado (y sin limitaciones en </Descripción>
<ID>158</ID><Size>2139</Size><Creación>Fri Dec  8 10:21:30 2017</Creación><Descripción>rmdir borra directorios vacíos Si un argumento directorio no se refiere a un directorio existente y vacío, es un error OPCIONES DE POSIX -p Si directorio incluye más de un componente en el camino, lo </Descripción>
<ID>159</ID><Size>2978</Size><Creación>Fri Dec  8 10:21:30 2017</Creación><Descripción>rpncalc emula parcialmente una HP 28S y está pensada para cálculos del día a día (por ejemplo 1 1 +), no para tareas complejas (en ese caso, use gnuplot(1) u octave(1) ) rpncalc evalúa la expresión da</Descripción>
<ID>160</ID><Size>10323</Size><Creación>Fri Dec  8 10:21:30 2017</Creación><Descripción>--NO POSEE DESCRIPCIÓN--</Descripción>
<ID>161</ID><Size>1840</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>Script hace una transcripción de cualquier cosa que sea impresa en su terminal Es útil para estudiantes que necesitan tener una copia de una sesión interactiva como una prueba de alguna asignatura, ya</Descripción>
<ID>162</ID><Size>4964</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>Sessreg es un simple programa para controlar las entradas utmp/wtmp en sesiones xdm El sistema V tiene un interfaz para /etc/utmp mejor que el de BSD; coloca las entradas de forma dinámica en el archi</Descripción>
<ID>163</ID><Size>3147</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>La orden setleds muestra y cambia los establecimientos de los LEDs (díodos luminosos, lucecitas) de una VT (terminal virtual) (a saber, BloqNum, BloqMay y BloqDespl) Sin argumentos, setleds muestra lo</Descripción>
<ID>164</ID><Size>1263</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>Sin argumentos, setmetamode muestra el modo actual de la tecla Meta Con un argumento, establece el modo de la tecla Meta como se indique Se informa del establecimiento antes y después del cambio El mo</Descripción>
<ID>165</ID><Size>3994</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>setterm escribe en la salida estándar una cadena de caracteres que activará las capacidades especificadas de la terminal Donde sea posible, se consultará a terminfo para encontrar la cadena a emplear </Descripción>
<ID>166</ID><Size>3317</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>showkey muestra en la salida estándar los códigos de rastreo o el código de tecla o el código `ascii' de cada tecla pulsada En los dos primeros modos el programa se ejecuta hasta que hayan transcurrid</Descripción>
<ID>167</ID><Size>3592</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>La utilidad size de GNU lista los tamaños de las secciones --y el tamaño total-- para cada uno de los ficheros objeto fichobj en su lista de argumentos De forma predeterminada, se genera una línea de </Descripción>
<ID>168</ID><Size>6299</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>Skill Envía la señal terminate a un conjunto de procesos Si se da un nombre ( o número ) de señal precedido por un "-", esa señal se sustituirá por terminate El comando skill -l muestra una lista de s</Descripción>
<ID>169</ID><Size>1117</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>Esta documentación no será mantenida y puede ser inexacta o incompleta La documentación Texinfo es ahora la fuente autorizada Esta página de manual documenta la versión GNU de sleep sleep detiene dura</Descripción>
<ID>170</ID><Size>687</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>sln hace una liga o enlace simbólico de dest a fuente Está enlazado estáticamente, por lo que no necesita en absoluto enlace dinámico De esta forma, sln es útil para realizar ligas simbólicas a biblio</Descripción>
<ID>171</ID><Size>6299</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>Skill Envía la señal terminate a un conjunto de procesos Si se da un nombre ( o número ) de señal precedido por un "-", esa señal se sustituirá por terminate El comando skill -l muestra una lista de s</Descripción>
<ID>172</ID><Size>3903</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>Para cada fichero dado, strings de GNU muestra las secuencias de caracteres imprimibles que sean de al menos 4 caracteres de largo (o del número dado con las opciones de más abajo) y que vayan seguida</Descripción>
<ID>173</ID><Size>5260</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>El programa strip de GNU quita todos los símbolos de los ficheros objeto fichobj La lista de ficheros objeto pude incluir archivos Por lo menos hay que dar un fichero objeto strip modifica los fichero</Descripción>
<ID>174</ID><Size>14784</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>Este documento ya no es mantenido y puede ser impreciso o incompleto La documentación de Texinfo es ahora la fuente de información recomendada Esta página del manual documenta la versión GNU de stty S</Descripción>
<ID>175</ID><Size>6747</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>Este documento ya no es mantenido y puede ser impreciso o incompleto La documentación de Texinfo es ahora la fuente de información recomendada Esta página del manual documenta la versión GNU de su su </Descripción>
<ID>176</ID><Size>35245</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>MODO 1 - modo stdout o de salida estándar %suck %suck minodo.com Suck obtiene mensajes de un servidor NNTP y envía los artículos a la salida estándar Suck acepta como argumento el nombre del servidor </Descripción>
<ID>177</ID><Size>8783</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>Esta página del Manual documenta la versión de GNU de tar, un programa archivador diseñado para almacenar y extraer ficheros de un fichero archivo conocido como un archivo- tar Esta página no es más q</Descripción>
<ID>178</ID><Size>1477</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>Este documento ya no es mantenido y puede ser impreciso o incompleto La documentación de Texinfo es ahora la fuente de información recomendada Esta página del manual documenta la versión GNU de tee El</Descripción>
<ID>179</ID><Size>48938</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>El comando telnet se usa en la comunicación interactiva con otro host que utilice el protocolo TELNET ("telnet> ") Si telnet es invocado con el parámetro host, la orden open se ejecuta implícitamente;</Descripción>
<ID>180</ID><Size>4618</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>Este documento ya no es mantenido y puede ser impreciso o incompleto La documentación de Texinfo es ahora la fuente de información recomendada Esta página del manual documenta la versión GNU de test H</Descripción>
<ID>181</ID><Size>3937</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>Testhost pide datos a un servidor NNTP, especificado por nodo La acción por defecto es ejecutar el comando help en el servidor que suele mostrar el software posee y los comandos que acepta Si se usa l</Descripción>
<ID>182</ID><Size>1388</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>tload imprime un gráfico del promedio de carga del sistema actual en la tty especificada (o la tty del proceso tload si no se especifica ninguna) Opciones La opción -s scala permite especificar una es</Descripción>
<ID>183</ID><Size>18349</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>top proporciona una visión continuada de la actividad del procesador en tiempo real Muestra un listado de las tareas que hacen un uso más intensivo de la CPU en el sistema, y puede proporcionar una in</Descripción>
<ID>184</ID><Size>6361</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>touch cambia la fecha de acceso y/o modificación del archivo especificado file Las fechas a cambiar son modificadas a la fecha actual, a menos q la opción -r sea especificada, en cuyo caso es cambiada</Descripción>
<ID>185</ID><Size>1329</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>Este documento ya no es mantenido y puede ser impreciso o incompleto La documentación de Texinfo es ahora la fuente de información recomendada Esta página del manual documenta la versión GNU de true (</Descripción>
<ID>186</ID><Size>1299</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>Tsort toma una lista de pares de nombres de nodos que representan arcos dirigidos en un grafo e imprime los nodos en orden topológico en la salida estándar La entrada se toma del fichero dado, fichero</Descripción>
<ID>187</ID><Size>1366</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>Esta documentación no va a ser mantenida a partir de ahora y puede ser inexacta o incompleta La documentación Texinfo es ahora la fuente autorizada Esta página de manual documenta la versión de GNU de</Descripción>
<ID>188</ID><Size>2043</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>Ul lee los ficheros dados (o la entrada estándar si no se da ninguno) y traduce caracteres subrayados a la secuencia que indique el subrayado para la terminal en uso, según se especifique en la variab</Descripción>
<ID>189</ID><Size>1703</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>Esta documentación no va a ser mantenida a partir de ahora y puede ser inexacta o incompleta La documentación Texinfo es ahora la fuente autorizada Esta página de manual documenta la versión de GNU de</Descripción>
<ID>190</ID><Size>3771</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>Esta página del Manual documenta la versión de GNU de updatedb, que actualiza las bases de datos de nombres de ficheros empleadas por el programa de GNU locate Las bases de datos de nombres de fichero</Descripción>
<ID>191</ID><Size>1113</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>uptime muestra una linea con la siguiente informacion La hora actual, cuanto tiempo lleva en marcha el sistema, el numero de usuarios actualmente conectados al sistema, y la carga media del sistema en</Descripción>
<ID>192</ID><Size>1514</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>Esta documentación no va a ser mantenida a partir de ahora y puede ser inexacta o incompleta La documentación Texinfo es ahora la fuente autorizada Esta página de manual documenta la versión de GNU de</Descripción>
<ID>193</ID><Size>2645</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>w muestra información sobre los usuarios que están conectados en ese momento a la máquina y sobre sus procesos La cabecera muestra, en este orden, el tiempo actual, cuanto lleva el sistema funcionando</Descripción>
<ID>194</ID><Size>736</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>Wall envía un mensaje a todos los terminales conectados con sus permisos mesg(1) puestos a yes El mensaje puede pasarse como un argumento a wall, o puede ser enviado a la entrada estándar de wall Cuan</Descripción>
<ID>195</ID><Size>891</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>watch es un programa basado en curses (3) que le permite mostrar un programa mientras cambia Por defecto, se actualiza el solo cada 2 segundos Puede especificar el número de segundos con la opción -n </Descripción>
<ID>196</ID><Size>656</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>whatis busca el contenido de palabra_clave, en una base de datos que contiene breves descripciones de los comandos, mostrando todas las descripciones que contienen una plabra idéntica (una plabra ente</Descripción>
<ID>197</ID><Size>2882</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>whereis localiza los fuentes, binarios y páginas del Manual para los programas que se especifiquen Primero, a los nombres suministrados se les quitan los componentes de la izquierda del camino y cualq</Descripción>
<ID>198</ID><Size>3109</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>Esta documentación no va a ser mantenida a partir de ahora y puede ser inexacta o incompleta La documentación Texinfo es ahora la fuente autorizada Esta página de manual documenta la versión de GNU de</Descripción>
<ID>199</ID><Size>952</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>Esta documentación no va a ser mantenida a partir de ahora y puede ser inexacta o incompleta La documentación Texinfo es ahora la fuente autorizada Esta página de manual documenta la versión de GNU de</Descripción>
<ID>200</ID><Size>2619</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>Write le permite comunicarse con otro usuario, copiando líneas de su terminal a la de él Cuando Ud llama a la orden write, el usuario al que Ud vaya a escribir recibe un mensaje de la forma: Message f</Descripción>
<ID>201</ID><Size>5918</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>Esta página del Manual documenta la versión de GNU de xargs xargs lee argumentos desde la entrada estándar, separados por blancos (que se pueden proteger con comillas simples o dobles o una barra incl</Descripción>
<ID>202</ID><Size>6649</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>--NO POSEE DESCRIPCIÓN--</Descripción>
<ID>203</ID><Size>1259</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>Esta documentación no va a ser mantenida a partir de ahora y puede ser inexacta o incompleta La documentación Texinfo es ahora la fuente autorizada Esta página de manual documenta la versión de GNU de</Descripción>
<ID>204</ID><Size>5516</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>Hostname es el programa que se utiliza para mostrar o establecer el nombre actual del sistema Muchos de los programas de trabajo en red usan este nombre para identificar a la máquina El NIS/YP también</Descripción>
<ID>205</ID><Size>19258</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>El programa gzip reduce el tamaño de los ficheros dados mediante el algoritmo de compresión de Lempel-Ziv (LZ77) Cuando es posible, cada fichero se reemplaza por otro con la extensión .gz, manteniéndo</Descripción>
<ID>206</ID><Size>1116</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>Zcmp y zdiff se usan para invocar los programas cmp o diff sobre ficheros comprimidos Todas las opciones especificadas se pasan directamente a cmp o diff Si sólo se especifica 1 fichero, entonces los </Descripción>
<ID>207</ID><Size>1116</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>Zcmp y zdiff se usan para invocar los programas cmp o diff sobre ficheros comprimidos Todas las opciones especificadas se pasan directamente a cmp o diff Si sólo se especifica 1 fichero, entonces los </Descripción>
<ID>208</ID><Size>890</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>zforce fuerza una extensión .gz en todos los ficheros gzip de modo que gzip no los comprima dos veces Esto puede ser útil para ficheros con nombres truncados tras una transferencia En sistemas con lim</Descripción>
<ID>209</ID><Size>1298</Size><Creación>Fri Dec  8 10:21:31 2017</Creación><Descripción>Zgrep es usado para invocar grep sobre ficheros comprimidos o "gzipeados" Todas las opciones especificadas se pasan directamente a grep Si no se especifica ningún fichero, entonces la entrada estándar</Descripción>
<ID>210</ID><Size>5886</Size><Creación>Fri Dec  8 10:21:32 2017</Creación><Descripción>--NO POSEE DESCRIPCIÓN--</Descripción>
<ID>211</ID><Size>1429</Size><Creación>Fri Dec  8 10:21:32 2017</Creación><Descripción>Znew recomprime ficheros de formato .Z (compress) a formato .gz (gzip) Si se desea recomprimir un fichero que ya está en formato gzip, renombrar el fichero a forzar a extensión .Z, y ejecutar znew OPC</Descripción>
<ID>212</ID><Size>7836</Size><Creación>Fri Dec  8 10:21:32 2017</Creación><Descripción>La función accept se usa con conectores orientados a conexión (SOCK_STREAM, SOCK_SEQPACKET y SOCK_RDM) Extrae la primera petición de conexión de la cola de conexiones pendientes, le asocia un nuevo co</Descripción>
<ID>213</ID><Size>4595</Size><Creación>Fri Dec  8 10:21:32 2017</Creación><Descripción>access comprueba si al proceso se le permitiría leer, escribir o comprobar la existencia del fichero (u otro objeto del sistema de ficheros) cuyo nombre es pathname Si pathname es un enlace simbólico </Descripción>
<ID>214</ID><Size>1857</Size><Creación>Fri Dec  8 10:21:32 2017</Creación><Descripción>Cuando se usa con el nombre de un fichero existente como argumento, se activa la contabilidad y se añade a filename un registro de información para cada proceso finalizado Usando NULL como argumento d</Descripción>
<ID>215</ID><Size>3852</Size><Creación>Fri Dec  8 10:21:32 2017</Creación><Descripción>Linux usa el algoritmo de David L Mills para ajustar el reloj adjtimex lee y opcionalmente prepara parámetros de ajuste para dicho algoritmo adjtimex toma un indicador a una estructura timex , actuali</Descripción>
<ID>216</ID><Size>1100</Size><Creación>Fri Dec  8 10:21:32 2017</Creación><Descripción>Estas llamadas al sistema no están implementadas en la versión 2.0 del núcleo de Linux VALOR DEVUELTO Estas llamadas al sistema siempre devuelven -1 y asignan a la variable errno el valor ENOSYS NOTAS</Descripción>
<ID>217</ID><Size>1193</Size><Creación>Fri Dec  8 10:21:32 2017</Creación><Descripción>alarm se encarga de enviar una señal SIGALRM al proceso en sec segundos Si sec es cero, no se prepara una nueva alarma Además, cualquier alarm previamente preparada se cancela VALOR DEVUELTO alarm dev</Descripción>
<ID>218</ID><Size>2403</Size><Creación>Fri Dec  8 10:21:32 2017</Creación><Descripción>bdflush inicia, limpia o ajusta el duende "bdflush" Solamente el superusuario puede llamar a bdflush Si func es negativo ó 0, y no se ha iniciado duende alguno, entonces bdflush entra en el código del</Descripción>
<ID>219</ID><Size>3627</Size><Creación>Fri Dec  8 10:21:32 2017</Creación><Descripción>bind da al conector sockfd la dirección local my_addr my_addr tiene una longitud de addrlen bytes Tradicionalmente, esto se conoce como "asignar un nombre a un conector." Cuando un conector se crea co</Descripción>
<ID>220</ID><Size>1100</Size><Creación>Fri Dec  8 10:21:32 2017</Creación><Descripción>Estas llamadas al sistema no están implementadas en la versión 2.0 del núcleo de Linux VALOR DEVUELTO Estas llamadas al sistema siempre devuelven -1 y asignan a la variable errno el valor ENOSYS NOTAS</Descripción>
<ID>221</ID><Size>1259</Size><Creación>Fri Dec  8 10:21:32 2017</Creación><Descripción>brk asigna el final del segmento de datos al valor especificado por end_data_segment end_data_segment debe ser mayor que el final del segmento de texto y debe estar 16 kB antes del final de la pila sb</Descripción>
<ID>222</ID><Size>1567</Size><Creación>Fri Dec  8 10:21:32 2017</Creación><Descripción>cacheflush vacía el contenido de la(s) caché(s) indicada(s) por las direcciones de usuario en el rango addr a (addr+nbytes-1) cache puede ser uno de los siguientes valores: ICACHE Purga la caché de in</Descripción>
<ID>223</ID><Size>2339</Size><Creación>Fri Dec  8 10:21:32 2017</Creación><Descripción>chdir cambia el directorio presente a aquel especificado en path fchdir es lo mismo que chdir, solo que el directorio está dado como un descriptor de fichero abierto VALOR DEVUELTO En caso de éxito, c</Descripción>
<ID>224</ID><Size>4824</Size><Creación>Fri Dec  8 10:21:32 2017</Creación><Descripción>Cambia el modo del fichero dado mediante path o referido por fildes Los modos se especifican mediante un O lógico de los siguientes valores: S_ISUID 04000 asignar ID de usuario al ejecutar S_ISGID 020</Descripción>
<ID>225</ID><Size>5040</Size><Creación>Fri Dec  8 10:21:32 2017</Creación><Descripción>Cambia el propietario del fichero especificado por path o fd Solamente el superusuario puede cambiar el propietario de un fichero El propietario de un fichero puede cambiar el grupo de dicho fichero a</Descripción>
<ID>226</ID><Size>2150</Size><Creación>Fri Dec  8 10:21:32 2017</Creación><Descripción>chroot cambia el directorio raíz a aquel especificado en path Este directorio será usado como raíz para aquellos nombres de camino que comiencen por / El directorio raíz es heredado por todos los desc</Descripción>
<ID>227</ID><Size>8461</Size><Creación>Fri Dec  8 10:21:32 2017</Creación><Descripción>__clone crea un nuevo proceso como lo hace fork(2) A diferencia de fork(2), __clone permite al proceso hijo compartir partes de su contexto de ejecución con su proceso padre, tales como el espacio de </Descripción>
<ID>228</ID><Size>2168</Size><Creación>Fri Dec  8 10:21:32 2017</Creación><Descripción>close cierra un descriptor de fichero de forma que ya no se refiera a fichero alguno y pueda ser reutilizado Cualesquiera bloqueos mantenidos sobre el fichero con el que estaba asociado, y propiedad d</Descripción>
<ID>229</ID><Size>5185</Size><Creación>Fri Dec  8 10:21:32 2017</Creación><Descripción>El descriptor de fichero sockfd debe referenciar a un conector Si el conector es del tipo SOCK_DGRAM entonces la dirección serv_addr es la dirección a la que por defecto se envían los datagramas y la </Descripción>
<ID>230</ID><Size>11737</Size><Creación>Fri Dec  8 10:21:32 2017</Creación><Descripción>La llamada al sistema open() se utiliza para convertir una ruta en un descriptor de fichero (un pequeño entero no negativo que se utiliza en las operaciones de E/S posteriores como en read, write, etc</Descripción>
<ID>231</ID><Size>1326</Size><Creación>Fri Dec  8 10:21:32 2017</Creación><Descripción>create_module intenta crear una entrada de módulo cargable y reserva la memoria del núcleo que se necesitará para alojar el módulo Esta llamada al sistema sólo está abierta al superusuario VALOR DEVUE</Descripción>
<ID>232</ID><Size>1194</Size><Creación>Fri Dec  8 10:21:32 2017</Creación><Descripción>delete_module intenta quitar una entrada de módulo cargable que no está en uso Si nombre es NULL, se quitan todos los módulos marcados como auto-descargables que no estén en uso Esta llamada al sistem</Descripción>
<ID>233</ID><Size>2043</Size><Creación>Fri Dec  8 10:21:32 2017</Creación><Descripción>dup y dup2 crean una copia del descriptor de fichero oldfd Los descriptores antiguo y nuevo pueden usarse indiferentemente Comparten candados (locks), indicadores de posición de fichero y banderas (fl</Descripción>
<ID>234</ID><Size>2043</Size><Creación>Fri Dec  8 10:21:32 2017</Creación><Descripción>dup y dup2 crean una copia del descriptor de fichero oldfd Los descriptores antiguo y nuevo pueden usarse indiferentemente Comparten candados (locks), indicadores de posición de fichero y banderas (fl</Descripción>
<ID>235</ID><Size>5861</Size><Creación>Fri Dec  8 10:21:32 2017</Creación><Descripción>execve() ejecuta el programa indicado por filename filename debe ser bien un binario ejecutable, bien un guión shell (shell script) comenzando con una línea de la forma "#! intérprete [arg]" En el seg</Descripción>
<ID>236</ID><Size>1271</Size><Creación>Fri Dec  8 10:21:32 2017</Creación><Descripción>_exit termina inmediatamente la ejecución del proceso invocador Todos los descriptores de ficheros abiertos que pertenezcan al proceso se cierran; todos los procesos hijos son heredados por el proceso</Descripción>
<ID>237</ID><Size>2339</Size><Creación>Fri Dec  8 10:21:32 2017</Creación><Descripción>chdir cambia el directorio presente a aquel especificado en path fchdir es lo mismo que chdir, solo que el directorio está dado como un descriptor de fichero abierto VALOR DEVUELTO En caso de éxito, c</Descripción>
<ID>238</ID><Size>4824</Size><Creación>Fri Dec  8 10:21:32 2017</Creación><Descripción>Cambia el modo del fichero dado mediante path o referido por fildes Los modos se especifican mediante un O lógico de los siguientes valores: S_ISUID 04000 asignar ID de usuario al ejecutar S_ISGID 020</Descripción>
<ID>239</ID><Size>5040</Size><Creación>Fri Dec  8 10:21:32 2017</Creación><Descripción>Cambia el propietario del fichero especificado por path o fd Solamente el superusuario puede cambiar el propietario de un fichero El propietario de un fichero puede cambiar el grupo de dicho fichero a</Descripción>
<ID>240</ID><Size>11705</Size><Creación>Fri Dec  8 10:21:32 2017</Creación><Descripción>fcntl realiza una de las diversas y variadas operaciones sobre fd La operación en cuestión se determina mediante cmd: F_DUPFD Hace que arg sea una copia de fd, cerrando fd si es necesario El mismo res</Descripción>
<ID>241</ID><Size>2062</Size><Creación>Fri Dec  8 10:21:32 2017</Creación><Descripción>fdatasync vuelca todos los búferes de datos de un fichero a disco (antes de que regrese la llamada al sistema) Se parece a fsync pero no requiere actualizar metadatos tales como la fecha/hora de acces</Descripción>
<ID>242</ID><Size>2422</Size><Creación>Fri Dec  8 10:21:32 2017</Creación><Descripción>Impone o elimina un candado de recomendación (advisory lock) en un fichero abierto El fichero está especificado por fd Las operaciones válidas son: LOCK_SH Candado compartido Más de un proceso puede t</Descripción>
<ID>243</ID><Size>1864</Size><Creación>Fri Dec  8 10:21:32 2017</Creación><Descripción>fork crea un proceso hijo que difiere de su proceso padre sólo en su PID y PPID, y en el hecho de que el uso de recursos esté asignado a 0 Los candados de fichero (file locks) y las señales pendientes</Descripción>
<ID>244</ID><Size>7305</Size><Creación>Fri Dec  8 10:21:32 2017</Creación><Descripción>Estas funciones devuelven información del fichero especificado No se necesitan derechos de acceso al fichero para conseguir la información pero sí se necesitan derechos de búsqueda para todos los dire</Descripción>
<ID>245</ID><Size>4812</Size><Creación>Fri Dec  8 10:21:32 2017</Creación><Descripción>statfs devuelve información de un sistema de ficheros montado path el el camino de cualquier fichero en el sistema de ficheros montado buf es un puntero a una estructura statfs definida como sigue: st</Descripción>
<ID>246</ID><Size>1097</Size><Creación>Fri Dec  8 10:21:32 2017</Creación><Descripción>fsync copia todas las partes que estén en memoria de un fichero al disco En algunas aplicaciones, fdatasync es una alternativa más eficiente a fsync VALOR DEVUELTO En caso de éxito, devuelve 0 En caso</Descripción>
<ID>247</ID><Size>2674</Size><Creación>Fri Dec  8 10:21:32 2017</Creación><Descripción>truncate hace que el fichero nombrado por path o referido por fd sea truncado a una longitud máxima de length bytes Si el fichero era mayor que dicha longitud, los datos extra se perderán Con ftruncat</Descripción>
<ID>248</ID><Size>2279</Size><Creación>Fri Dec  8 10:21:32 2017</Creación><Descripción>getdents lee varias estructuras dirent del directorio señalado por el puntero fd en el área de memoria señalada por dirp El parámetro count es el tamaño del área de memoria La estructura dirent se dec</Descripción>
<ID>249</ID><Size>1338</Size><Creación>Fri Dec  8 10:21:32 2017</Creación><Descripción>Estas funciones se usan para acceder o cambiar el nombre de dominio del procesador actual Si el nombre del dominio es de longitud mayor que len, getdomainname devuelve los primeros len bytes VALOR DEV</Descripción>
<ID>250</ID><Size>921</Size><Creación>Fri Dec  8 10:21:32 2017</Creación><Descripción>getdtablesize devuelve el número máximo de ficheros que un proceso puede tener abiertos NOTAS getdtablesize está implementada como una función de biblioteca en DLL 4.4.1 Esta función devuelve OPEN_MAX</Descripción>
<ID>251</ID><Size>884</Size><Creación>Fri Dec  8 10:21:32 2017</Creación><Descripción>getgid devuelve el ID (identificador) real del grupo del proceso actual getegid devuelve el ID 'efectivo' del grupo del proceso actual El ID real se corresponde con el ID del proceso invocador El ID e</Descripción>
<ID>252</ID><Size>883</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>getuid devuelve el identificador de usuario real del proceso actual geteuid devuelve el identificador de usuario efectivo del proceso actual El identificador real corresponde con el del proceso invoca</Descripción>
<ID>253</ID><Size>884</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>getgid devuelve el ID (identificador) real del grupo del proceso actual getegid devuelve el ID 'efectivo' del grupo del proceso actual El ID real se corresponde con el ID del proceso invocador El ID e</Descripción>
<ID>254</ID><Size>2037</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>getgroups Se devuelven como mucho size grupos suplementarios en list Si size es cero, list no se modifica, pero se devuelve el número total de grupos suplementarios para el proceso setgroups Asigna lo</Descripción>
<ID>255</ID><Size>1414</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>Obtiene o asigna un identificador único de 32-bits para el ordenador actual El identificador de 32-bits pretende ser único entre todos los sistemas UNIX existentes Este normalmente asemeja la direcció</Descripción>
<ID>256</ID><Size>1799</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>Estas funciones se usan para obtener o cambiar el nombre del host del proceso actual VALOR DEVUELTO En caso de éxito devuelve un 0 En caso de error,devuelve un -1, y errno se asigna apropiadamente ERR</Descripción>
<ID>257</ID><Size>4543</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>El sistema proporciona a cada proceso 3 temporizadores, los cuales se decrementan en distintas escalas de tiempo Cuando ha pasado el intervalo de tiempo definido en el temporizador, se envía una señal</Descripción>
<ID>258</ID><Size>1037</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>Devuelve el número de bytes de una página Éste es el tamaño de página del sistema, que no es necesariamente el mismo que el tamaño de página de hardware OBSERVACIONES getpagesize está implementada com</Descripción>
<ID>259</ID><Size>1930</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>Getpeername devuelve el nombre de la pareja conectada al zócalo s El parámetro longinom debería inicializarse de forma que indicara la cantidad de espacio a la que apuntara nombre Al regresar la funci</Descripción>
<ID>260</ID><Size>2396</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>setpgid pone el ID de grupo de proceso del especificado por pid a pgid Si pid es cero, se emplea el PID del proceso en curso Si pgid es cero, se emplea el PID del proceso especificado por pid getpgid </Descripción>
<ID>261</ID><Size>2396</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>setpgid pone el ID de grupo de proceso del especificado por pid a pgid Si pid es cero, se emplea el PID del proceso en curso Si pgid es cero, se emplea el PID del proceso especificado por pid getpgid </Descripción>
<ID>262</ID><Size>752</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>getpid devuelve el identificador de proceso del proceso actual (Esto es usado normalmente por rutinas que generan nombres únicos de ficheros temporales.) getppid devuelve el identificador de proceso d</Descripción>
<ID>263</ID><Size>752</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>getpid devuelve el identificador de proceso del proceso actual (Esto es usado normalmente por rutinas que generan nombres únicos de ficheros temporales.) getppid devuelve el identificador de proceso d</Descripción>
<ID>264</ID><Size>2804</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>La prioridad de planificación del proceso, grupo de procesos o usuario, según se indique en which y who se obtiene con la función getpriority y se asigna con setpriority Which puede ser PRIO_PROCESS, </Descripción>
<ID>265</ID><Size>1131</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>getresuid and getresgid (ambos introducidos en Linux 2.1.44) devuelven en ID real, efectivo y salvado del usuario (resp ID de grupo) del proceso actual VALOR DEVUELTO Si es correcto, devuelve el valor</Descripción>
<ID>266</ID><Size>1131</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>getresuid and getresgid (ambos introducidos en Linux 2.1.44) devuelven en ID real, efectivo y salvado del usuario (resp ID de grupo) del proceso actual VALOR DEVUELTO Si es correcto, devuelve el valor</Descripción>
<ID>267</ID><Size>4352</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>getrlimit y setrlimit devuelve / establece el límite de recursos, respectivamente resource debería ser uno de los siguientes: RLIMIT_CPU /* tiempo de CPU en segundos */ RLIMIT_FSIZE /* tamaño Máximo d</Descripción>
<ID>268</ID><Size>4352</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>getrlimit y setrlimit devuelve / establece el límite de recursos, respectivamente resource debería ser uno de los siguientes: RLIMIT_CPU /* tiempo de CPU en segundos */ RLIMIT_FSIZE /* tamaño Máximo d</Descripción>
<ID>269</ID><Size>770</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>getsid(0) devuelve el identificador de sesión del proceso invocador getsid(p) devuelve el identificador de sesión del proceso con identificador p ERRORES En caso de error, se devuelve -1 El único erro</Descripción>
<ID>270</ID><Size>1817</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>Getsockname devuelve el nombre actual para la conexión indicada El parámetro namelen debe ser inicializado para indicar la cantidad de espacio apuntador por name La devolución contiene el tamaño actua</Descripción>
<ID>271</ID><Size>4385</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>Getsockopt y setsockopt manipulan las opciones asociadas a un conector Éstas pueden existir en múltiples niveles de protocolo; siempre están presentes en el nivel más alto de conector Al manipular opc</Descripción>
<ID>272</ID><Size>4711</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>gettimeofday y settimeofday pueden poner tanto la hora como una zona horaria tv es una estructura timeval, tal como se especifica en /usr/include/sys/time.h: struct timeval { long tv_sec; /* segundos </Descripción>
<ID>273</ID><Size>883</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>getuid devuelve el identificador de usuario real del proceso actual geteuid devuelve el identificador de usuario efectivo del proceso actual El identificador real corresponde con el del proceso invoca</Descripción>
<ID>274</ID><Size>1765</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>Si tabla es NULL, get_kernel_syms devuelve el número de símbolos disponibles para consultar En otro caso rellena una tabla de estructuras: struct kernel_sym { unsigned long value; char name[60]; }; Lo</Descripción>
<ID>275</ID><Size>1100</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>Estas llamadas al sistema no están implementadas en la versión 2.0 del núcleo de Linux VALOR DEVUELTO Estas llamadas al sistema siempre devuelven -1 y asignan a la variable errno el valor ENOSYS NOTAS</Descripción>
<ID>276</ID><Size>1027</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>idle es una llamada al sistema interna utilizada durante el arranque del sistema Marca las paginas de memoria del proceso intercambiables y entra en el bucle principal del planificador idle nunca regr</Descripción>
<ID>277</ID><Size>2565</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>init_module carga la imagen del módulo relocalizado en el espacio del núcleo y ejecuta la función init del módulo La imagen del módulo comienza con una estructura de módulo seguida por código y datos </Descripción>
<ID>278</ID><Size>6156</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>Este capítulo describe las llamadas al sistema de Linux En syscalls(2) encontrará una lista de las 164 llamadas al sistema presentes en Linux 2.0 Llamadas directas En la mayoría de los casos no es nec</Descripción>
<ID>279</ID><Size>2141</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>La función ioctl manipula los parámetros subyacentes de ficheros especiales En particular, muchas características operacionales de los ficheros especiales de caracteres (verbigracia las terminales) pu</Descripción>
<ID>280</ID><Size>33216</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>--NO POSEE DESCRIPCIÓN--</Descripción>
<ID>281</ID><Size>1660</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>Ioperm establece los bits de permiso de acceso a los puertos para el proceso para num bytes, empezando desde la dirección del puerto desde, al valor encender El empleo de ioperm requiere privilegios d</Descripción>
<ID>282</ID><Size>2209</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>iopl cambia el nivel de privilegio de E/S del proceso en curso, según se especifique en nivel Esta llamada es necesaria para permitir a los servidores X compatibles con las tarjetas de vídeo 8514 ejec</Descripción>
<ID>283</ID><Size>1213</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>ipc es un punto de entrada al núcleo común para las llamadas IPC de System V para mensajes, semáforos y memoria compartida El argumento llamada determina a qué función de IPC se ha de llamar; los otro</Descripción>
<ID>284</ID><Size>2349</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>La llamada kill se puede usar para enviar cualquier señal a un proceso o grupo de procesos Si pid es positivo, entonces la señal sig es enviada a pid En este caso, se devuelve 0 si hay éxito, o un val</Descripción>
<ID>285</ID><Size>1641</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>Killpg envía la señal sig al grupo de procesos pgrp Véase sigaction(2) para una lista de señales Si pgrp es 0, killpg envía la señal al grupo de procesos del proceso que envía la señal El proceso que </Descripción>
<ID>286</ID><Size>5040</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>Cambia el propietario del fichero especificado por path o fd Solamente el superusuario puede cambiar el propietario de un fichero El propietario de un fichero puede cambiar el grupo de dicho fichero a</Descripción>
<ID>287</ID><Size>3250</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>link crea un nuevo enlace (también conocido como enlace físico) a un fichero existente Si newpath existe, no será sobreescrito Este nuevo nombre podrá ser usado exactamente igual que el viejo para cua</Descripción>
<ID>288</ID><Size>2763</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>Para aceptar conexiones, primero se crea un conector con socket(2), luego se especifica con listen el deseo de aceptar conexiones entrantes y un límite de la cola para dichas conexiones, y por último </Descripción>
<ID>289</ID><Size>1560</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>La función _llseek reposiciona el puntero del descriptor de fichero fd hasta (offset_high<<32) | offset_low bytes respecto al inicio del fichero, la posición actual del puntero, o del final del ficher</Descripción>
<ID>290</ID><Size>1100</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>Estas llamadas al sistema no están implementadas en la versión 2.0 del núcleo de Linux VALOR DEVUELTO Estas llamadas al sistema siempre devuelven -1 y asignan a la variable errno el valor ENOSYS NOTAS</Descripción>
<ID>291</ID><Size>2909</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>La función lseek reposiciona el puntero del descriptor de fichero fildes con el argumento offset de acuerdo con la directiva whence as follows: SEEK_SET El puntero se coloca a offset bytes SEEK_CUR El</Descripción>
<ID>292</ID><Size>7305</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>Estas funciones devuelven información del fichero especificado No se necesitan derechos de acceso al fichero para conseguir la información pero sí se necesitan derechos de búsqueda para todos los dire</Descripción>
<ID>293</ID><Size>3147</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>mkdir intenta crear un directorio de nombre pathname mode especifica los permisos a usar Es modificado por la umask (máscara de usuario) del proceso de la forma habitual: los permisos del fichero crea</Descripción>
<ID>294</ID><Size>4767</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>mknod intenta crear en el sistema de ficheros un nodo-i (fichero, fichero especial de dispositivo o tubería nombrada (FIFO)) llamado pathname, especificado por mode y dev mode especifica tanto los per</Descripción>
<ID>295</ID><Size>3499</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>mlock desactiva el paginado para la memoria en el grupo de direcciones que comienza en la dirección addr con longitud len bytes Se garantiza que todas las páginas que contienen algunas de esas direcci</Descripción>
<ID>296</ID><Size>5472</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>mlockall desactiva el paginado para todas las páginas asociadas en el espacio de direcciones del proceso que hace la llamada Esto incluye las páginas del código, de los datos y del segmento de pila, a</Descripción>
<ID>297</ID><Size>3971</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>La función mmap intenta ubicar length bytes comenzando en el desplazamiento offset desde el fichero (u otro objeto) espeficicado por fd en memoria, preferiblemente en la dirección start Esta última di</Descripción>
<ID>298</ID><Size>1848</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>modify_ldt lee o escribe la tabla local de descriptores (ldt) para un proceso La ldt es una tabla de gestión de memoria por proceso empleada por el procesador i386 Para más información sobre esta tabl</Descripción>
<ID>299</ID><Size>4783</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>mount engarza el sistema de ficheros especificado por fespecial (que es frecuentemente un nombre de dispositivo) al directorio especificado por dir umount desengancha el sistema de ficheros especifica</Descripción>
<ID>300</ID><Size>3573</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>mprotect controla la forma en que una sección de memoria puede ser accedida Si un acceso no es permitido por la protección dada, el programa recibe un SIGSEGV prot es un O-lógico a nivel de bits de lo</Descripción>
<ID>301</ID><Size>1100</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>Estas llamadas al sistema no están implementadas en la versión 2.0 del núcleo de Linux VALOR DEVUELTO Estas llamadas al sistema siempre devuelven -1 y asignan a la variable errno el valor ENOSYS NOTAS</Descripción>
<ID>302</ID><Size>4081</Size><Creación>Fri Dec  8 10:21:33 2017</Creación><Descripción>mremap expande (o encoge) una asociación existente de memoria, moviéndola potencialmente a la vez (según se controle por el argumento flags y según el espacio de direcciones virtuales disponible) viej</Descripción>
<ID>303</ID><Size>3862</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>La función ejecuta la operación especificada por cmd en la cola de mensajes con el identificador msqid Valores legales para cmd son: IPC_STAT Copia información desde la estructura de datos mensaje en </Descripción>
<ID>304</ID><Size>4811</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>La función devuelve el identificador de la cola de mensajes asociada a key Se crea una nueva cola de mensajes si key tiene el valor IPC_PRIVATE, o si key no es IPC_PRIVATE pero no existe ninguna cola </Descripción>
<ID>305</ID><Size>9039</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>Para enviar o recibir un mensaje, el proceso llamador aloja una estructura como la siguiente: struct msgbuf { long mtype; /* tipo de msj., debe ser > 0 */ char mtext[1]; /* datos del mensaje */ }; per</Descripción>
<ID>306</ID><Size>9039</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>Para enviar o recibir un mensaje, el proceso llamador aloja una estructura como la siguiente: struct msgbuf { long mtype; /* tipo de msj., debe ser > 0 */ char mtext[1]; /* datos del mensaje */ }; per</Descripción>
<ID>307</ID><Size>9039</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>Para enviar o recibir un mensaje, el proceso llamador aloja una estructura como la siguiente: struct msgbuf { long mtype; /* tipo de msj., debe ser > 0 */ char mtext[1]; /* datos del mensaje */ }; per</Descripción>
<ID>308</ID><Size>2046</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>msync vuelca a disco los cambios hechos en la copia en memoria de un fichero que ha sido mapeado en memoria empleando mmap (2) Sin la utilización de esta llamada no está garantizado que los cambios se</Descripción>
<ID>309</ID><Size>2081</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>munlock vuelve a activar la paginación para la zona de memoria que cae en el rango que comienza en la dirección addr con longitud len bytes Todas las páginas que contienen una parte del rango de memor</Descripción>
<ID>310</ID><Size>1406</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>munlockall vuelve a habilitar la paginación para todas las páginas asociadas al espacio de direcciones del proceso que hace esta llamada Los bloqueos de memoria no se apilan; esto es, las páginas que </Descripción>
<ID>311</ID><Size>3971</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>La función mmap intenta ubicar length bytes comenzando en el desplazamiento offset desde el fichero (u otro objeto) espeficicado por fd en memoria, preferiblemente en la dirección start Esta última di</Descripción>
<ID>312</ID><Size>3531</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>nanosleep retarda la ejecución del programa durante al menos el tiempo especificado en *req La función puede regresar antes si se ha mandado una señal al proceso En este caso, devuelve -1, pone errno </Descripción>
<ID>313</ID><Size>1914</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>/* * Éstas son las órdenes comprendidas por nfsctl() */ #define NFSCTL_SVC 0 /* Esto es un proceso servidor */ #define NFSCTL_ADDCLIENT 1 /* Añadir un cliente NFS */ #define NFSCTL_DELCLIENT 2 /* Quit</Descripción>
<ID>314</ID><Size>1177</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>nice añade inc a la prioridad del proceso que hace la llamada Sólo el súper-usuario puede especificar un incremento negativo, o sea, un aumento de la prioridad Observe que internamente, un número más </Descripción>
<ID>315</ID><Size>1006</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>El núcleo Linux 2.0 implementa estas llamadas para dar soporte a ejecutables antiguos Estas llamadas devuelven estructuras que han crecido desde su primera implementación, pero los ejecutables antiguo</Descripción>
<ID>316</ID><Size>1006</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>El núcleo Linux 2.0 implementa estas llamadas para dar soporte a ejecutables antiguos Estas llamadas devuelven estructuras que han crecido desde su primera implementación, pero los ejecutables antiguo</Descripción>
<ID>317</ID><Size>1006</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>El núcleo Linux 2.0 implementa estas llamadas para dar soporte a ejecutables antiguos Estas llamadas devuelven estructuras que han crecido desde su primera implementación, pero los ejecutables antiguo</Descripción>
<ID>318</ID><Size>1006</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>El núcleo Linux 2.0 implementa estas llamadas para dar soporte a ejecutables antiguos Estas llamadas devuelven estructuras que han crecido desde su primera implementación, pero los ejecutables antiguo</Descripción>
<ID>319</ID><Size>1006</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>El núcleo Linux 2.0 implementa estas llamadas para dar soporte a ejecutables antiguos Estas llamadas devuelven estructuras que han crecido desde su primera implementación, pero los ejecutables antiguo</Descripción>
<ID>320</ID><Size>1006</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>El núcleo Linux 2.0 implementa estas llamadas para dar soporte a ejecutables antiguos Estas llamadas devuelven estructuras que han crecido desde su primera implementación, pero los ejecutables antiguo</Descripción>
<ID>321</ID><Size>11737</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>La llamada al sistema open() se utiliza para convertir una ruta en un descriptor de fichero (un pequeño entero no negativo que se utiliza en las operaciones de E/S posteriores como en read, write, etc</Descripción>
<ID>322</ID><Size>1503</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>Esta familia de funciones se emplea para hacer entrada y salida de bajo nivel por puertos Están diseñadas principalmente para uso interno del núcleo, pero pueden ser empleadas desde el espacio del usu</Descripción>
<ID>323</ID><Size>647</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>La llamada al sistema pause hace que el proceso en curso se duerma hasta que reciba una señal VALOR DEVUELTO pause siempre devuelve -1, y errno toma el valor ERESTARTNOHAND ERRORES EINTR se ha recibid</Descripción>
<ID>324</ID><Size>1409</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>Linux admite diferentes dominios de ejecución, o personalidades, para cada proceso Entre otras cosas, los dominios de ejecución le dicen a Linux cómo asociar números de señal a acciones a tomar para c</Descripción>
<ID>325</ID><Size>1007</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>pipe crea un par de descriptores de ficheros, que apuntan a un nodo-í de una tubería, y los pone en el vector de dos elementos apuntado por descf descf[0] es para lectura, descf[1] es para escritura V</Descripción>
<ID>326</ID><Size>3611</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>poll es una variación de select Especifica un vector de nfds estructuras del tipo struct pollfd { int fd; /* Descriptor de fichero */ short events; /* Eventos solicitados */ short revents; /* Eventos </Descripción>
<ID>327</ID><Size>2068</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>prctl es llamada con un primer argumento especificando qué hacer (con los valores definidos en <linux/prctl.h>), y con más parámetros cuyo significado depende del primero Por el momento la única opció</Descripción>
<ID>328</ID><Size>2131</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>pread() lee hasta count bytes del descriptor de fichero fd a partir de la posición offset (desde el principio del fichero) en el área temporal que empieza en buf La posición del puntero de L/E del fic</Descripción>
<ID>329</ID><Size>1100</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>Estas llamadas al sistema no están implementadas en la versión 2.0 del núcleo de Linux VALOR DEVUELTO Estas llamadas al sistema siempre devuelven -1 y asignan a la variable errno el valor ENOSYS NOTAS</Descripción>
<ID>330</ID><Size>2745</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>Ptrace porporciona un medio por el que un proceso padre puede controlar la ejecución de un proceso hijo, y examinar y cambiar su imagen de memoria Su uso primordial es en la implementación de depuraci</Descripción>
<ID>331</ID><Size>2131</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>pread() lee hasta count bytes del descriptor de fichero fd a partir de la posición offset (desde el principio del fichero) en el área temporal que empieza en buf La posición del puntero de L/E del fic</Descripción>
<ID>332</ID><Size>3794</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>query_module pide información al núcleo relativa a módulos cargables La naturaleza precisa de la información y su formato depende de la subfunción que Algunas funciones requieren que nombre se refiera</Descripción>
<ID>333</ID><Size>4155</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>El sistema de cuotas define para cada usuario o grupo un límite blando y un límite duro limitando la cantidad de espacio de disco que puede usarse en un sistema de ficheros dado EL límite duro no pued</Descripción>
<ID>334</ID><Size>4031</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>read() intenta leer hasta nbytes bytes del fichero cuyo descriptor de fichero es fd y guardarlos en la zona de memoria que empieza en buf Si nbytes es cero, read() devuelve cero y no tiene otro efecto</Descripción>
<ID>335</ID><Size>2543</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>Esta no es la funcion que buscabas Mira readdir(3) para ver la interfase de la biblioteca C que se conforma a POSIX Esta página documenta la interfaz desnuda de la llamada de sistema del kernel, que p</Descripción>
<ID>336</ID><Size>1935</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>readlink pone los contenidos del enlace simbólico camino en el búfer buf, que tiene de tamaño tambuf readlink no añade un carácter NUL a buf Truncará los contenidos (hasta una longitud de tambuf carac</Descripción>
<ID>337</ID><Size>3155</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>readv lee datos desde el descriptor de fichero fd y pone los resultados en la zona de memoria descrita por vector El número de bloques de memoria se especifica en count Los bloques se llenan en el ord</Descripción>
<ID>338</ID><Size>5000</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>La llamada reboot rearranca el sistema o habilita/inhabilita la pulsación de rearranque (abreviada CAS, ya que por defecto es Ctrl-Alt-Supr; se puede cambiar usando loadkeys(1)) Esta llamada al sistem</Descripción>
<ID>339</ID><Size>11733</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>Las llamadas recvfrom y recvmsg se emplean para recibir mensajes desde un conector (``socket''), y pueden utilizarse para recibir datos de un conector sea orientado a conexión o no Si desde no es NULL</Descripción>
<ID>340</ID><Size>11733</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>Las llamadas recvfrom y recvmsg se emplean para recibir mensajes desde un conector (``socket''), y pueden utilizarse para recibir datos de un conector sea orientado a conexión o no Si desde no es NULL</Descripción>
<ID>341</ID><Size>11733</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>Las llamadas recvfrom y recvmsg se emplean para recibir mensajes desde un conector (``socket''), y pueden utilizarse para recibir datos de un conector sea orientado a conexión o no Si desde no es NULL</Descripción>
<ID>342</ID><Size>5825</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>rename renombre un fichero, moviéndolo entre directorios si así se requiere Cualquier otro enlace físico al fichero (como los creados usando link) no se ve afectado Si newpath ya existe será automátic</Descripción>
<ID>343</ID><Size>2506</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>rmdir borra un directorio, el cual debe estar vacío VALOR DEVUELTO Si éxito, se devuelve un cero Si error, -1 es devuelto, y errno está configurado apropiadamente ERRORES EPERM El sistema de ficheros </Descripción>
<ID>344</ID><Size>1259</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>brk asigna el final del segmento de datos al valor especificado por end_data_segment end_data_segment debe ser mayor que el final del segmento de texto y debe estar 16 kB antes del final de la pila sb</Descripción>
<ID>345</ID><Size>2951</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>sched_setparam establece los parámetros de planificación asociados con la política de planificación para el proceso identificado por pid Si pid es cero, entonces se establecen los parámetros del proce</Descripción>
<ID>346</ID><Size>11026</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>sched_setscheduler establece tanto la política de planificación como los parámetros asociados para el proceso identificado por pid Si pid es igual a cero, se establece el planificador del proceso que </Descripción>
<ID>347</ID><Size>3011</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>sched_get_priority_max devuelve el valor de máxima prioridad que puede emplearse con el algoritmo de planificación identificado por politica sched_get_priority_min devuelve el valor de mínima priorida</Descripción>
<ID>348</ID><Size>3011</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>sched_get_priority_max devuelve el valor de máxima prioridad que puede emplearse con el algoritmo de planificación identificado por politica sched_get_priority_min devuelve el valor de mínima priorida</Descripción>
<ID>349</ID><Size>2216</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>sched_rr_get_interval escribe en la estructura timespec apuntada por tp el cuanto (quantum) de tiempo de asignación en rueda (round robin) para el proceso identificado por pid Si pid es cero, el cuant</Descripción>
<ID>350</ID><Size>2951</Size><Creación>Fri Dec  8 10:21:34 2017</Creación><Descripción>sched_setparam establece los parámetros de planificación asociados con la política de planificación para el proceso identificado por pid Si pid es cero, entonces se establecen los parámetros del proce</Descripción>
<ID>351</ID><Size>11026</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>sched_setscheduler establece tanto la política de planificación como los parámetros asociados para el proceso identificado por pid Si pid es igual a cero, se establece el planificador del proceso que </Descripción>
<ID>352</ID><Size>1431</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>Un proceso puede abandonar el procesador voluntariamente sin bloquearse llamando a sched_yield Entonces el proceso se pondrá al final de la cola para su prioridad estática y un nuevo proceso obtendrá </Descripción>
<ID>353</ID><Size>4859</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>select espera a que una serie de descriptores de ficheros cambien su estado Se miran tres conjuntos independientes de descriptores Aquéllos listados en readfds serán observados para ver si hay caracte</Descripción>
<ID>354</ID><Size>8611</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>La función realiza la operación de control especificada por cmd en el conjunto de semáforos (o en el semáforo semnum-avo del grupo) identificado por semid El primer semáforo del conjunto está indicado</Descripción>
<ID>355</ID><Size>6235</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>La función devuelve el identificador del conjunto de semáforos asociado al valor del argumento key Un nuevo conjunto de nsems semáforos se crea si key tiene el valor IPC_PRIVATE, o si key no vale IPC_</Descripción>
<ID>356</ID><Size>8745</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>Esta función ejecuta operaciones en los miembros seleccionados del semaforo indi cado por semid Cada uno de los nsops elementos en el array apuntado por sops especifica una operación a ser realizada e</Descripción>
<ID>357</ID><Size>6108</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>Send, sendto y sendmsg son utilizados para transmitir un mensaje a otro conector Send solo puede ser usado cuando un conector está en un estado connected mientras sendto y sendmsg pueden ser utilizado</Descripción>
<ID>358</ID><Size>2354</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>Esta llamada copia datos entre un descriptor de fichero y otro Cualquiera de los dos descriptores de fichero o los dos pueden referirse a un conector (socket) in_fd debe ser un descriptor de fichero a</Descripción>
<ID>359</ID><Size>6108</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>Send, sendto y sendmsg son utilizados para transmitir un mensaje a otro conector Send solo puede ser usado cuando un conector está en un estado connected mientras sendto y sendmsg pueden ser utilizado</Descripción>
<ID>360</ID><Size>6108</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>Send, sendto y sendmsg son utilizados para transmitir un mensaje a otro conector Send solo puede ser usado cuando un conector está en un estado connected mientras sendto y sendmsg pueden ser utilizado</Descripción>
<ID>361</ID><Size>1338</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>Estas funciones se usan para acceder o cambiar el nombre de dominio del procesador actual Si el nombre del dominio es de longitud mayor que len, getdomainname devuelve los primeros len bytes VALOR DEV</Descripción>
<ID>362</ID><Size>1859</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>setregid establece los GIDs real y efectivo del proceso en curso Los usuarios no privilegiados pueden cambiar el GID real al GID efectivo y viceversa Antes de Linux 1.1.38, lo del ID salvado, cuando s</Descripción>
<ID>363</ID><Size>2013</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>setreuid define el ID de usuario real y efectivo del proceso actual Los usuarios sin privilegios pueden cambiar el ID de usuario del efectivo al real y viceversa Anteriormente a Linux 1.1.37, el parad</Descripción>
<ID>364</ID><Size>1887</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>setfsgid establece el identificativo de grupo que el núcleo de Linux usa para comprobar todos los accesos al sistema de ficheros Normalmente, el valor de fsgid cambiará según el valor del grupo efecti</Descripción>
<ID>365</ID><Size>1903</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>setfsuid establece el identificativo de usuario que el núcleo de Linux usa para comprobar todos los accesos al sistema de ficheros Normalmente, el valor de fsuid cambiará según el valor del usuario ef</Descripción>
<ID>366</ID><Size>1963</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>setgid establece el ID de grupo efectivo del proceso en curso Si quien llama a la función es el súper-usuario, se ponen también las IDs de grupo real y salvado Bajo Linux, setgid está implementada com</Descripción>
<ID>367</ID><Size>2037</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>getgroups Se devuelven como mucho size grupos suplementarios en list Si size es cero, list no se modifica, pero se devuelve el número total de grupos suplementarios para el proceso setgroups Asigna lo</Descripción>
<ID>368</ID><Size>1414</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>Obtiene o asigna un identificador único de 32-bits para el ordenador actual El identificador de 32-bits pretende ser único entre todos los sistemas UNIX existentes Este normalmente asemeja la direcció</Descripción>
<ID>369</ID><Size>1799</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>Estas funciones se usan para obtener o cambiar el nombre del host del proceso actual VALOR DEVUELTO En caso de éxito devuelve un 0 En caso de error,devuelve un -1, y errno se asigna apropiadamente ERR</Descripción>
<ID>370</ID><Size>4543</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>El sistema proporciona a cada proceso 3 temporizadores, los cuales se decrementan en distintas escalas de tiempo Cuando ha pasado el intervalo de tiempo definido en el temporizador, se envía una señal</Descripción>
<ID>371</ID><Size>2396</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>setpgid pone el ID de grupo de proceso del especificado por pid a pgid Si pid es cero, se emplea el PID del proceso en curso Si pgid es cero, se emplea el PID del proceso especificado por pid getpgid </Descripción>
<ID>372</ID><Size>2396</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>setpgid pone el ID de grupo de proceso del especificado por pid a pgid Si pid es cero, se emplea el PID del proceso en curso Si pgid es cero, se emplea el PID del proceso especificado por pid getpgid </Descripción>
<ID>373</ID><Size>2804</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>La prioridad de planificación del proceso, grupo de procesos o usuario, según se indique en which y who se obtiene con la función getpriority y se asigna con setpriority Which puede ser PRIO_PROCESS, </Descripción>
<ID>374</ID><Size>1859</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>setregid establece los GIDs real y efectivo del proceso en curso Los usuarios no privilegiados pueden cambiar el GID real al GID efectivo y viceversa Antes de Linux 1.1.38, lo del ID salvado, cuando s</Descripción>
<ID>375</ID><Size>1763</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>setresuid (introducido en Linux 2.1.44) establece el UID real, efectivo y salvado del proceso en curso Los procesos de usuarios no privilegiados (esto es, procesos con cada uno de los UIDs real, efect</Descripción>
<ID>376</ID><Size>1763</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>setresuid (introducido en Linux 2.1.44) establece el UID real, efectivo y salvado del proceso en curso Los procesos de usuarios no privilegiados (esto es, procesos con cada uno de los UIDs real, efect</Descripción>
<ID>377</ID><Size>2013</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>setreuid define el ID de usuario real y efectivo del proceso actual Los usuarios sin privilegios pueden cambiar el ID de usuario del efectivo al real y viceversa Anteriormente a Linux 1.1.37, el parad</Descripción>
<ID>378</ID><Size>4352</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>getrlimit y setrlimit devuelve / establece el límite de recursos, respectivamente resource debería ser uno de los siguientes: RLIMIT_CPU /* tiempo de CPU en segundos */ RLIMIT_FSIZE /* tamaño Máximo d</Descripción>
<ID>379</ID><Size>1680</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>setsid() crea una nueva sesión si el proceso que realiza la llamada no es lider de grupo de procesos El proceso que realiza la llamada es lider de la nueva sesión, lider de grupo de procesos del nuevo</Descripción>
<ID>380</ID><Size>4385</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>Getsockopt y setsockopt manipulan las opciones asociadas a un conector Éstas pueden existir en múltiples niveles de protocolo; siempre están presentes en el nivel más alto de conector Al manipular opc</Descripción>
<ID>381</ID><Size>4711</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>gettimeofday y settimeofday pueden poner tanto la hora como una zona horaria tv es una estructura timeval, tal como se especifica en /usr/include/sys/time.h: struct timeval { long tv_sec; /* segundos </Descripción>
<ID>382</ID><Size>2623</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>setuid establece el UID efectivo del proceso en curso Si el UID efectivo de quien llama a esta rutina es root, también se establecen los identificadores de usuario real y salvado Bajo Linux, setuid es</Descripción>
<ID>383</ID><Size>1062</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>setup se llama una vez desde linux/init/main.c Llama a funciones de inicio para dispositivos y sistemas de ficheros configurados en el núcleo y luego monta el sistema de ficheros raíz Ningún proceso d</Descripción>
<ID>384</ID><Size>3283</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>La llamada al sistema signal instala un nuevo manejador de señal para la señal cuyo número es signum El manejador de señal se establece como manejador, que puede ser una función especificada por el us</Descripción>
<ID>385</ID><Size>5932</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>La función shmat pega el segmento de memoria compartida identificada por shmid al segmento de datos del proceso que llama a la función La dirección del pegado se especifica en shmaddr según uno de los</Descripción>
<ID>386</ID><Size>6023</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>shmctl() permite al usuario recibir información sobre un segmento de memoria compartida, establecer el dueño, grupo y permisos del segmento, así como destruirlo La información sobre el segmento identi</Descripción>
<ID>387</ID><Size>5932</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>La función shmat pega el segmento de memoria compartida identificada por shmid al segmento de datos del proceso que llama a la función La dirección del pegado se especifica en shmaddr según uno de los</Descripción>
<ID>388</ID><Size>7961</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>shmget() devuelve el identificativo del segmento de memoria compartida asociado al valor del argumento key Se crea un nuevo segmento de memoria compartida, de tamaño igual al múltiplo de PAGE_SIZE más</Descripción>
<ID>389</ID><Size>5932</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>La función shmat pega el segmento de memoria compartida identificada por shmid al segmento de datos del proceso que llama a la función La dirección del pegado se especifica en shmaddr según uno de los</Descripción>
<ID>390</ID><Size>1307</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>La llamada a shutdown causa que se cierre completamente o en parte una conexión bidireccional en el zócalo asociado con s Si como es 0, no se permitirán más recepciones Si como es 1, no se permitirán </Descripción>
<ID>391</ID><Size>16947</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>La llamad al sistema sigaction se emplea para cambiar la acción tomada por un proceso cuando recibe una determinada señal signum especifica la señal y puede ser cualquiera válida salvo SIGKILL o SIGST</Descripción>
<ID>392</ID><Size>1964</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>Esta interfaz está anticuada desde que existe sigprocmask(2) La llamada al sistema sigblock añade las señales especificadas en mascara al conjunto de señales que actualmente están bloqueadas para su e</Descripción>
<ID>393</ID><Size>1964</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>Esta interfaz está anticuada desde que existe sigprocmask(2) La llamada al sistema sigblock añade las señales especificadas en mascara al conjunto de señales que actualmente están bloqueadas para su e</Descripción>
<ID>394</ID><Size>1964</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>Esta interfaz está anticuada desde que existe sigprocmask(2) La llamada al sistema sigblock añade las señales especificadas en mascara al conjunto de señales que actualmente están bloqueadas para su e</Descripción>
<ID>395</ID><Size>3283</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>La llamada al sistema signal instala un nuevo manejador de señal para la señal cuyo número es signum El manejador de señal se establece como manejador, que puede ser una función especificada por el us</Descripción>
<ID>396</ID><Size>1091</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>Esta interfaz está anticuada desde que existe sigsuspend(2) sigpause asigna sigmask al conjunto de señales enmascaradas y luego espera que llegue una señal; al regresar, se restaura el conjunto de señ</Descripción>
<ID>397</ID><Size>16947</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>La llamad al sistema sigaction se emplea para cambiar la acción tomada por un proceso cuando recibe una determinada señal signum especifica la señal y puede ser cualquiera válida salvo SIGKILL o SIGST</Descripción>
<ID>398</ID><Size>16947</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>La llamad al sistema sigaction se emplea para cambiar la acción tomada por un proceso cuando recibe una determinada señal signum especifica la señal y puede ser cualquiera válida salvo SIGKILL o SIGST</Descripción>
<ID>399</ID><Size>1309</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>Cuando el kernel de Linux crea la estructura de pila para el manejador de señales, inserta una llamada a sigreturn en la estructura de pila aunque el manejador de señales llamará a sigreturn a su vuel</Descripción>
<ID>400</ID><Size>1964</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>Esta interfaz está anticuada desde que existe sigprocmask(2) La llamada al sistema sigblock añade las señales especificadas en mascara al conjunto de señales que actualmente están bloqueadas para su e</Descripción>
<ID>401</ID><Size>16947</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>La llamad al sistema sigaction se emplea para cambiar la acción tomada por un proceso cuando recibe una determinada señal signum especifica la señal y puede ser cualquiera válida salvo SIGKILL o SIGST</Descripción>
<ID>402</ID><Size>654</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>Este interface se hace obsoleto por sigaction(2) Bajo Linux sigvec es una macro definida mediante sigaction, y sirve como la más tosca aproximación del interface BSD sigvec CONFORME A BSD, SVr4 VÉASE </Descripción>
<ID>403</ID><Size>9478</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>Socket crea un extremo de una comunicación y devuelve un descriptor El parámetro dominio especifica un dominio de comunicaciones Esto selecciona la familia de protocol que se usará para la comunicació</Descripción>
<ID>404</ID><Size>1324</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>socketcall es un punto de entrada al núcleo común para las llamadas al sistema relativas a zócalos El argumento llamada determina a qué función de zócalos llamar El parámetro args apunta a un bloque q</Descripción>
<ID>405</ID><Size>1816</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>La llamada a crea una pareja sin nombre de zócalos (`sockets', enchufes) en el dominio especificado por d, del tipo especificado por tipo, y empleando opcionalmente el protocolo especificado por proto</Descripción>
<ID>406</ID><Size>3283</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>La llamada al sistema signal instala un nuevo manejador de señal para la señal cuyo número es signum El manejador de señal se establece como manejador, que puede ser una función especificada por el us</Descripción>
<ID>407</ID><Size>7305</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>Estas funciones devuelven información del fichero especificado No se necesitan derechos de acceso al fichero para conseguir la información pero sí se necesitan derechos de búsqueda para todos los dire</Descripción>
<ID>408</ID><Size>4812</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>statfs devuelve información de un sistema de ficheros montado path el el camino de cualquier fichero en el sistema de ficheros montado buf es un puntero a una estructura statfs definida como sigue: st</Descripción>
<ID>409</ID><Size>875</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>stime pone la hora y fecha según la idea que el sistema tiene de ello La hora/fecha, a la que apunta t, se mide en segundos transcurridos desde "La Época", las 00:00:00 GMT del 1 de Enero de 1970 stim</Descripción>
<ID>410</ID><Size>1100</Size><Creación>Fri Dec  8 10:21:35 2017</Creación><Descripción>Estas llamadas al sistema no están implementadas en la versión 2.0 del núcleo de Linux VALOR DEVUELTO Estas llamadas al sistema siempre devuelven -1 y asignan a la variable errno el valor ENOSYS NOTAS</Descripción>
<ID>411</ID><Size>3293</Size><Creación>Fri Dec  8 10:21:36 2017</Creación><Descripción>swapon establece como área de trasiego el fichero o dispositivo de bloques especificado por camino swapoff para el trasiego al fichero o dispositivo de bloque especificado por camino swapon toma un ar</Descripción>
<ID>412</ID><Size>3293</Size><Creación>Fri Dec  8 10:21:36 2017</Creación><Descripción>swapon establece como área de trasiego el fichero o dispositivo de bloques especificado por camino swapoff para el trasiego al fichero o dispositivo de bloque especificado por camino swapon toma un ar</Descripción>
<ID>413</ID><Size>3691</Size><Creación>Fri Dec  8 10:21:36 2017</Creación><Descripción>symlink crea un enlace simbólico llamado caminonuevo que contiene la cadena de caracteres caminoviejo A fin de encontrar un fichero o directorio, los enlaces simbólicos se interpretan en tiempo de eje</Descripción>
<ID>414</ID><Size>951</Size><Creación>Fri Dec  8 10:21:36 2017</Creación><Descripción>sync primero entrega los nodos-í a los búferes, y luego éstos al disco VALOR DEVUELTO sync siempre devuelve 0 CONFORME A SVr4, SVID, X/OPEN, BSD 4.3 FALLOS De acuerdo con la especificación del estánda</Descripción>
<ID>415</ID><Size>5888</Size><Creación>Fri Dec  8 10:21:36 2017</Creación><Descripción>En Linux 2.0.34 hay 164 llamadas al sistema listadas en /usr/include/asm/unistd.h Esta página de manual las lista (incorporando hipervínculos si lee esto con un browser apropiado) _llseek(2), _newsele</Descripción>
<ID>416</ID><Size>3963</Size><Creación>Fri Dec  8 10:21:36 2017</Creación><Descripción>La llamada _sysctl lee o escribe parámetros del núcleo Por ejemplo, el nombre del computador, o el número máximo de ficheros abiertos El argumento tiene la forma struct __sysctl_args { int *name; /* v</Descripción>
<ID>417</ID><Size>1933</Size><Creación>Fri Dec  8 10:21:36 2017</Creación><Descripción>sysfs devuelve información sobre el sistema de ficheros presente en el kernel La form a concreta de la llamada sysfs y la información devuelta depende de option eso es: 1 Traduce la tira que identific</Descripción>
<ID>418</ID><Size>2058</Size><Creación>Fri Dec  8 10:21:36 2017</Creación><Descripción>sysinfo devuelve información en la siguiente estructura: struct sysinfo { long uptime; /* Segundos desde el arranque */ unsigned long loads[3]; /* cargas medias en 1, 5, y 15 min */ unsigned long tota</Descripción>
<ID>419</ID><Size>5529</Size><Creación>Fri Dec  8 10:21:36 2017</Creación><Descripción>Probablemente no es ésta la función que le interesa Mire syslog(3) para la interfaz de la biblioteca de C Esta página documenta sólo la interfaz de la llamada al sistema desnuda El argumento tipo dete</Descripción>
<ID>420</ID><Size>2203</Size><Creación>Fri Dec  8 10:21:36 2017</Creación><Descripción>time devuelve el tiempo transcurrido, medido en segundos, desde `la Época': las 0 horas 0 minutos 0 segundos, tiempo universal coordinado, del 1 de Enero de 1970 Esta medida se llama el ``tiempo de ca</Descripción>
<ID>421</ID><Size>1024</Size><Creación>Fri Dec  8 10:21:36 2017</Creación><Descripción>times guarda los tiempos del proceso en curso en el sitio al que apunta buf struct tms está definida así en /usr/include/sys/times.h: struct tms { clock_t tms_utime; /* tiempo de usuario */ clock_t tm</Descripción>
<ID>422</ID><Size>2674</Size><Creación>Fri Dec  8 10:21:36 2017</Creación><Descripción>truncate hace que el fichero nombrado por path o referido por fd sea truncado a una longitud máxima de length bytes Si el fichero era mayor que dicha longitud, los datos extra se perderán Con ftruncat</Descripción>
<ID>423</ID><Size>1122</Size><Creación>Fri Dec  8 10:21:36 2017</Creación><Descripción>umask establece la máscara de usuario a mask & 0777 La máscara de usuario es usada por open(2) para establecer los permisos iniciales de un fichero recién creado Específicamente, los permisos presente</Descripción>
<ID>424</ID><Size>4783</Size><Creación>Fri Dec  8 10:21:36 2017</Creación><Descripción>mount engarza el sistema de ficheros especificado por fespecial (que es frecuentemente un nombre de dispositivo) al directorio especificado por dir umount desengancha el sistema de ficheros especifica</Descripción>
<ID>425</ID><Size>1091</Size><Creación>Fri Dec  8 10:21:36 2017</Creación><Descripción>uname devuelve información del sistema en buf La estructura utsname es tal como se define en <sys/utsname.h>: struct utsname { char sysname[SYS_NMLN]; char nodename[SYS_NMLN]; char release[SYS_NMLN]; </Descripción>
<ID>426</ID><Size>1282</Size><Creación>Fri Dec  8 10:21:36 2017</Creación><Descripción>A partir de la versión 2.0.34, hay 164 llamadas al sistema listadas en el fichero /usr/include/asm/unistd.h Esta página de manual menciona aquellas llamadas que están implementadas en el núcleo pero q</Descripción>
<ID>427</ID><Size>1100</Size><Creación>Fri Dec  8 10:21:36 2017</Creación><Descripción>Estas llamadas al sistema no están implementadas en la versión 2.0 del núcleo de Linux VALOR DEVUELTO Estas llamadas al sistema siempre devuelven -1 y asignan a la variable errno el valor ENOSYS NOTAS</Descripción>
<ID>428</ID><Size>3210</Size><Creación>Fri Dec  8 10:21:36 2017</Creación><Descripción>unlink borra un nombre del sistema de ficheros Si dicho nombre era el último enlace a un fichero, y ningún proceso tiene el fichero abierto, el fichero es borrado y el espacio que ocupaba vuelve a est</Descripción>
<ID>429</ID><Size>1172</Size><Creación>Fri Dec  8 10:21:36 2017</Creación><Descripción>uselib selecciona el fichero binario de la biblioteca compartida que será empleado por este proceso VALOR DEVUELTO En caso de éxito se devuelve cero En caso de error se devuelve -1 y se pone en errno </Descripción>
<ID>430</ID><Size>2032</Size><Creación>Fri Dec  8 10:21:36 2017</Creación><Descripción>ustat devuelve información sobre un sistema de ficheros montado dev es un número de dispositivo que identifica a uno que contiene un sistema de ficheros montado ubuf es un puntero a una estructura ust</Descripción>
<ID>431</ID><Size>1979</Size><Creación>Fri Dec  8 10:21:36 2017</Creación><Descripción>utime cambia los tiempos de acceso y modificación del nodo-í especificado por nombrefichero a los campos actime y modtime de buf respectivamente Si buf es NULL, entonces los tiempos de acceso y modifi</Descripción>
<ID>432</ID><Size>1979</Size><Creación>Fri Dec  8 10:21:36 2017</Creación><Descripción>utime cambia los tiempos de acceso y modificación del nodo-í especificado por nombrefichero a los campos actime y modtime de buf respectivamente Si buf es NULL, entonces los tiempos de acceso y modifi</Descripción>
<ID>433</ID><Size>1864</Size><Creación>Fri Dec  8 10:21:36 2017</Creación><Descripción>fork crea un proceso hijo que difiere de su proceso padre sólo en su PID y PPID, y en el hecho de que el uso de recursos esté asignado a 0 Los candados de fichero (file locks) y las señales pendientes</Descripción>
<ID>434</ID><Size>845</Size><Creación>Fri Dec  8 10:21:36 2017</Creación><Descripción>vhangup simula un cuelgue en la terminal en uso Esta llamada hace que otros usuarios obtengan una tty "limpia" cuando entren en el sistema VALOR DEVUELTO En caso de éxito, se devuelve cero En caso de </Descripción>
<ID>435</ID><Size>1328</Size><Creación>Fri Dec  8 10:21:36 2017</Creación><Descripción>La llamada al sistema vm86 fue introducida en Linux 0.97p2 En Linux 2.1.15 y 2.0.28 se renombró como vm86old, y se introdujo una nueva vm86 La definición de la `struct vm86_struct' se cambió en 1.1.8 </Descripción>
<ID>436</ID><Size>5691</Size><Creación>Fri Dec  8 10:21:36 2017</Creación><Descripción>La función wait suspende la ejecución del proceso actual haste que un proceso hijo ha terminado, o hasta que se produce una señal cuya acción es terminar el proceso actual o llamar a la función maneja</Descripción>
<ID>437</ID><Size>5484</Size><Creación>Fri Dec  8 10:21:36 2017</Creación><Descripción>La función wait3 suspende la ejecución del proceso actual hasta que finalice un hijo o hasta que se produzca una señal cuya acción sea finalizar el proceso actual o llamar a una función manejadora de </Descripción>
<ID>438</ID><Size>5484</Size><Creación>Fri Dec  8 10:21:36 2017</Creación><Descripción>La función wait3 suspende la ejecución del proceso actual hasta que finalice un hijo o hasta que se produzca una señal cuya acción sea finalizar el proceso actual o llamar a una función manejadora de </Descripción>
<ID>439</ID><Size>5691</Size><Creación>Fri Dec  8 10:21:36 2017</Creación><Descripción>La función wait suspende la ejecución del proceso actual haste que un proceso hijo ha terminado, o hasta que se produce una señal cuya acción es terminar el proceso actual o llamar a la función maneja</Descripción>
<ID>440</ID><Size>2961</Size><Creación>Fri Dec  8 10:21:36 2017</Creación><Descripción>write escribe hasta num bytes en el fichero referenciado por el descriptor de fichero fd desde el búfer que comienza en buf POSIX requiere que un read() que pueda demostrarse que ocurra después que un</Descripción>
<ID>441</ID><Size>3155</Size><Creación>Fri Dec  8 10:21:36 2017</Creación><Descripción>readv lee datos desde el descriptor de fichero fd y pone los resultados en la zona de memoria descrita por vector El número de bloques de memoria se especifica en count Los bloques se llenan en el ord</Descripción>
<ID>442</ID><Size>1271</Size><Creación>Fri Dec  8 10:21:36 2017</Creación><Descripción>_exit termina inmediatamente la ejecución del proceso invocador Todos los descriptores de ficheros abiertos que pertenezcan al proceso se cierran; todos los procesos hijos son heredados por el proceso</Descripción>
<ID>443</ID><Size>1560</Size><Creación>Fri Dec  8 10:21:36 2017</Creación><Descripción>La función _llseek reposiciona el puntero del descriptor de fichero fd hasta (offset_high<<32) | offset_low bytes respecto al inicio del fichero, la posición actual del puntero, o del final del ficher</Descripción>
<ID>444</ID><Size>4859</Size><Creación>Fri Dec  8 10:21:36 2017</Creación><Descripción>select espera a que una serie de descriptores de ficheros cambien su estado Se miran tres conjuntos independientes de descriptores Aquéllos listados en readfds serán observados para ver si hay caracte</Descripción>
<ID>445</ID><Size>3963</Size><Creación>Fri Dec  8 10:21:36 2017</Creación><Descripción>La llamada _sysctl lee o escribe parámetros del núcleo Por ejemplo, el nombre del computador, o el número máximo de ficheros abiertos El argumento tiene la forma struct __sysctl_args { int *name; /* v</Descripción>
<ID>446</ID><Size>846</Size><Creación>Fri Dec  8 10:21:36 2017</Creación><Descripción>La función abort() causa una terminación anormal a menos que se capture la señal SIGABORT y el manejador de señales no regrese Si la función abort() causa la terminación de un programa, todos los cana</Descripción>
<ID>447</ID><Size>675</Size><Creación>Fri Dec  8 10:21:36 2017</Creación><Descripción>La función abs() calcula el valor absoluto del argumento entero j VALOR DEVUELTO Devuelve el valor absoluto del argumento entero CONFORME A SVID 3, POSIX, BSD 4.3, ISO 9899 NOTAS Intentar tomar el val</Descripción>
<ID>448</ID><Size>826</Size><Creación>Fri Dec  8 10:21:36 2017</Creación><Descripción>La función acos() calcula el arco coseno de x; éste es el valor cuyo coseno es x Si x está fuera del rango -1 a 1, acos() falla y a errno se le asigna un valor apropiado VALOR DEVUELTO La función acos</Descripción>
<ID>449</ID><Size>727</Size><Creación>Fri Dec  8 10:21:36 2017</Creación><Descripción>La función acosh() calcula el arco coseno hyperbólico de x; éste es el valor cuyo coseno hyperbólico es x Si x es menor que 1.0, acosh() devuelve NaN (not-a-number, no es un número) y a errno se le as</Descripción>
<ID>450</ID><Size>3242</Size><Creación>Fri Dec  8 10:21:36 2017</Creación><Descripción>Estas rutinas se emplean para acceder al fichero que describe los sistemas de ficheros, /etc/fstab, y el que describe los sistemas de ficheros que están montados, /etc/mtab La función setmntent() abre</Descripción>
<ID>451</ID><Size>1028</Size><Creación>Fri Dec  8 10:21:36 2017</Creación><Descripción>La función alloca concede size bytes de espacio en el marco de pila (stack frame) del invocador Este espacio temporal se libera automáticamente a la salida de una función VALOR DEVUELTO La función all</Descripción>
<ID>452</ID><Size>2310</Size><Creación>Fri Dec  8 10:21:36 2017</Creación><Descripción>La función scandir() rastrea el directorio dir, llamando select() en cada entrada de directorio Las entradas para las que select() devuelve un valor distinto de cero se almacenan en cadenas (strings) </Descripción>
<ID>453</ID><Size>6099</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>La funciones ctime(), gmtime() y localtime() toman todas un argumento de tipo time_t que representa el tiempo de calendario Al ser interpretado como un valor de tiempo absoluto, representa el número d</Descripción>
<ID>454</ID><Size>819</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>La función asin() calcula el arco seno de x; esto es, el valor cuyo seno es x Si x cae fuera del rango -1 a 1, asin() falla y errno toma un valor apropiado VALOR DEVUELTO La función asin() devuelve el</Descripción>
<ID>455</ID><Size>533</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>La función asinh() calcula el arco seno hyperbólico de x; éste es el valor cuyo seno hiperbólico es x CONFORME A SVID 3, POSIX, BSD 4.3, ISO 9899 VÉASE TAMBIÉN acosh(3), atanh(3), cosh(3), sinh(3), ta</Descripción>
<ID>456</ID><Size>1049</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>assert() imprime un mensaje de error a la salida estándar y termina el programa llamando a abort() si expression es falsa (es decir, es igual a cero) Esto sólo sucede cuando la macro NDEBUG está sin d</Descripción>
<ID>457</ID><Size>694</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>La función atan() calcula el arco tangente de x; este es el valor cuya tangente es x VALOR DEVUELTO La función atan() devuelve el arco tangente en radianes; el valor se define matemáticamente para est</Descripción>
<ID>458</ID><Size>822</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>La función atan2() calcula el arco tangente de las dos variables x e y Es similar a calcular el arco tangente de y / x, excepto en que los signos de ambos argumentos son usados para determinar el cuad</Descripción>
<ID>459</ID><Size>735</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>La función atanh() calcula la arco tangente hiperbólica de x; es decir, el valor cuya tangente hiperbólica es x Si el valor absoluto de x es mayor que 1.0, atanh() devuelve no-es-número (NaN) y se asi</Descripción>
<ID>460</ID><Size>954</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>La función atexit() registra function para ser llamada al momento de una terminación normal, tanto por vía de exit(3) o de un retorno desde main Las funciones así registradas se llaman en orden invers</Descripción>
<ID>461</ID><Size>727</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>La función atof() convierte la porción inicial de la cadena apuntada por nptr a un double El comportamiento es el mismo que strtod(nptr, (char **)NULL); excepto que atof() no detecta errores VALOR DEV</Descripción>
<ID>462</ID><Size>725</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>La función atoi() convierte la porción inicial de la cadena apuntada por nptr a int El comportamiento es el mismo que strtol(nptr, (char **)NULL, 10); excepto que atoi() no detecta errores VALOR DEVUE</Descripción>
<ID>463</ID><Size>747</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>La función atol() convierte la porción inicial de la cadena apuntada por nptr a un entero largo El comportamiento es el mismo que strtol(nptr, (char **)NULL, 10); excepto que atol() no detecta errores</Descripción>
<ID>464</ID><Size>866</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>La función bcmp() compara los primeros n bytes de las cadenas s1 y s2 Si las dos cadenas son iguales, bcmp() devuelve 0, en otro caso devuelve un resultado distinto de cero Si n es cero, se asume que </Descripción>
<ID>465</ID><Size>651</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>La función bcopy() copia los primeros n bytes de la cadena fuente src a la cadena destino dest Si n es cero, no se copia ningún byte VALOR DEVUELTO La función bcopy() no devuelve ningún valor CONFORME</Descripción>
<ID>466</ID><Size>1538</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>La función bsearch() busca en un arreglo de nmemb elementos, donde el primer elemento está apuntado por base, un elemento que coincida con el objecto apuntado por key El tamaño de cada elementos del a</Descripción>
<ID>467</ID><Size>1436</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>Las funciones de cadenas de bytes ejecutan operaciones sobre cadenas que no terminan en NULL Vea las páginas de manual individuales para las descripciones de cada una de las funciones VÉASE TAMBIÉN bc</Descripción>
<ID>468</ID><Size>9257</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>La rutina dbopen es la interfaz de biblioteca para los ficheros de bases de datos Uno de los formatos de fichero soportado es el de los ficheros árbolB La descripción general de los métodos de acceso </Descripción>
<ID>469</ID><Size>1480</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>La función htonl() convierte el entero largo hostlong desde el orden de bytes del host al de la red La función htons() convierte el entero corto hostshort desde el orden de bytes del host al de la red</Descripción>
<ID>470</ID><Size>616</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>La función bzero() pone a cero los n primeros bytes de la cadena de bytes s VALOR DEVUELTO La función bzero() no devuelve ningún valor CONFORME A BSD 4.3 Esta función está desaconsejada -- use memset </Descripción>
<ID>471</ID><Size>4258</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>calloc() asigna memoria para una matriz de nmemb elementos de size bytes cada uno y devuelve un puntero a la memoria asignada La memoria es puesta a cero malloc() asigna size bytes y devuelve un punte</Descripción>
<ID>472</ID><Size>2777</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>catopen() abre un catálogo de mensajes y devuelve un descriptor de catálogo name espeficica el nombre del catálogo de mensajes a ser abierto Si name especifica un camino absoluto, (i.e contiene una `/</Descripción>
<ID>473</ID><Size>1965</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>catgets() lee el mensaje message_number, en el conjunto set_number, del catálogo de mensajes identificado por catalog, donde catalog es un descriptor de catálogo devuelto por una llamada anterior a ca</Descripción>
<ID>474</ID><Size>2777</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>catopen() abre un catálogo de mensajes y devuelve un descriptor de catálogo name espeficica el nombre del catálogo de mensajes a ser abierto Si name especifica un camino absoluto, (i.e contiene una `/</Descripción>
<ID>475</ID><Size>546</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>La función cbrt() devuelve la raiz cúbica de x Esta función no puede fallar; todo valor real representable tiene una raiz cúbica real representable CONFORME A cbrt es una extensión de GNU VÉASE TAMBIÉ</Descripción>
<ID>476</ID><Size>543</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>La función ceil() redondea x hacia arriba al entero más cercano, devolviendo el valor como un double CONFORME A SVID 3, POSIX, BSD 4.3, ISO 9899 VÉASE TAMBIÉN abs(3), fabs(3), floor(3), labs(3), rint(</Descripción>
<ID>477</ID><Size>14809</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>Las funciones termios describen una interfaz general para las terminales que sirve para controlar los puertos de comunicaciones asícronas Muchas de las funciones que aquí se describen poseen un argume</Descripción>
<ID>478</ID><Size>14809</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>Las funciones termios describen una interfaz general para las terminales que sirve para controlar los puertos de comunicaciones asícronas Muchas de las funciones que aquí se describen poseen un argume</Descripción>
<ID>479</ID><Size>14809</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>Las funciones termios describen una interfaz general para las terminales que sirve para controlar los puertos de comunicaciones asícronas Muchas de las funciones que aquí se describen poseen un argume</Descripción>
<ID>480</ID><Size>14809</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>Las funciones termios describen una interfaz general para las terminales que sirve para controlar los puertos de comunicaciones asícronas Muchas de las funciones que aquí se describen poseen un argume</Descripción>
<ID>481</ID><Size>14809</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>Las funciones termios describen una interfaz general para las terminales que sirve para controlar los puertos de comunicaciones asícronas Muchas de las funciones que aquí se describen poseen un argume</Descripción>
<ID>482</ID><Size>1460</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>La función clearerr limpia los indicadores de fin-de- fichero y error para el flujo indicado por flujo La función feof inspecciona el indicador de fin-de-fichero para el flujo indicado por flujo, devo</Descripción>
<ID>483</ID><Size>1025</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>La función clock() devuelve una aproximación del tiempo del procesador usado por el programa VALOR DEVUELTO El valor devuelto es el tiempo de CPU usado medido en clock_t; para obtener el equivalente e</Descripción>
<ID>484</ID><Size>854</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>La función closedir() cierra el canal del directorio asociado con dir El descriptor del canal del directorio dir no estará disponible después de esta llamada VALOR DEVUELTO La función closedir() devue</Descripción>
<ID>485</ID><Size>4457</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>closelog() cierra el descriptor que se esté usando para escribir en el registrador del sistema El empleo de closelog() es opcional openlog() abre, para un programa, una conexión con el registrador del</Descripción>
<ID>486</ID><Size>7098</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>Estas macros se usan para crear y acceder a mensajes de control (también llamados datos auxiliares) que no son parte del contenido útil de un conector Esta información de control puede incluir la inte</Descripción>
<ID>487</ID><Size>1948</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>confstr() obtiene el valor de una variable cadena dependiente de la configuración El argumento name es la variable del sistema a ser examinada Se admiten las siguientes variables: _CS_PATH Un valor pa</Descripción>
<ID>488</ID><Size>465</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>La función copysign() devuelve un valor cuyo valor absoluto coincide con x, pero cuyo signo coincide con el de y CONFORME A BSD 4.3 GNU 25 Diciembre 1995 COPYSIGN(3) </Descripción>
<ID>489</ID><Size>568</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>La función cos() devuelve el coseno de x, donde x está dado en radianes VALOR DEVUELTO La función cos() devuelve un valor entre -1 y 1 CONFORME A SVID 3, POSIX, BSD 4.3, ISO 9899 VÉASE TAMBIÉN acos(3)</Descripción>
<ID>490</ID><Size>541</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>La función cosh() devuelve el coseno hiperbólico de x, que está definido matemáticamente como exp(x) + exp(-x) / 2 CONFORME A SVID 3, POSIX, BSD 4.3, ISO 9899 VÉASE TAMBIÉN acosh(3), asinh(3), atanh(3</Descripción>
<ID>491</ID><Size>4433</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>crypt es la función de cifrado de contraseñas Está basada en el algoritmo DES (Data Encryption Standard) con algunas variaciones tendentes (junto con otras cosas) a desalentar el uso de implementacion</Descripción>
<ID>492</ID><Size>1019</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>ctermid() devuelve una cadena que es el camino de la terminal controlador actual para este proceso Si s es NULL, se emplea un búfer estático; si no, s apunta a un búfer usado para contener el camino d</Descripción>
<ID>493</ID><Size>6099</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>La funciones ctime(), gmtime() y localtime() toman todas un argumento de tipo time_t que representa el tiempo de calendario Al ser interpretado como un valor de tiempo absoluto, representa el número d</Descripción>
<ID>494</ID><Size>3222</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>getlogin devuelve un puntero a una cadena de caracteres que contiene el nombre del usuario que está en la terminal controladora del proceso, o un puntero nulo si esta información no puede determinarse</Descripción>
<ID>495</ID><Size>16401</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>Dbopen es la interfaz de biblioteca para los ficheros de bases de datos Los formatos de fichero soportados son árbolB, dispersión y ficheros orientados a UNIX El formato árbolB es una representación d</Descripción>
<ID>496</ID><Size>16401</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>Dbopen es la interfaz de biblioteca para los ficheros de bases de datos Los formatos de fichero soportados son árbolB, dispersión y ficheros orientados a UNIX El formato árbolB es una representación d</Descripción>
<ID>497</ID><Size>785</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>La función difftime() devuelve el número de segundos transcurridos entre time1 y time0 Los dos tiempos se dan como tiempo de calendario, que representa el tiempo transcurrido desde las 00:00:00 h del </Descripción>
<ID>498</ID><Size>647</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>La función div() calcula el valor numer/denom y devuelve el cociente y el resto en una estructura llamada div_t que contiene dos miembros llamados quot y rem VALOR DEVUELTO La estructura div_t CONFORM</Descripción>
<ID>499</ID><Size>6466</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>dlopen carga una biblioteca dinámica desde el fichero nombrado por la cadena que termina con el valor nulo nomfich y devuelve un "manejador" opaco para la biblioteca dinámica Si nomfich no es un camin</Descripción>
<ID>500</ID><Size>6466</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>dlopen carga una biblioteca dinámica desde el fichero nombrado por la cadena que termina con el valor nulo nomfich y devuelve un "manejador" opaco para la biblioteca dinámica Si nomfich no es un camin</Descripción>
<ID>501</ID><Size>6466</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>dlopen carga una biblioteca dinámica desde el fichero nombrado por la cadena que termina con el valor nulo nomfich y devuelve un "manejador" opaco para la biblioteca dinámica Si nomfich no es un camin</Descripción>
<ID>502</ID><Size>6466</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>dlopen carga una biblioteca dinámica desde el fichero nombrado por la cadena que termina con el valor nulo nomfich y devuelve un "manejador" opaco para la biblioteca dinámica Si nomfich no es un camin</Descripción>
<ID>503</ID><Size>7185</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>Estas funciones hacen peticiones e interpretan las respuestas de los servidores de nombres de dominio de Internet La función res_init() lee los ficheros de configuración (ver resolv+(8)) para consegui</Descripción>
<ID>504</ID><Size>7185</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>Estas funciones hacen peticiones e interpretan las respuestas de los servidores de nombres de dominio de Internet La función res_init() lee los ficheros de configuración (ver resolv+(8)) para consegui</Descripción>
<ID>505</ID><Size>4233</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>Estas funciones generan números seudo-aleatorios usando el algoritmo congruente lineal y artimética de enteros de 48 bits Las funciones drand48() y erand48() devuelven valores en coma flotante de dobl</Descripción>
<ID>506</ID><Size>832</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>La función drem() calcula el resto de la división de x entre y El valor devuelto es x - n * y, donde n es el cociente de x / y, redondeado al entero más cercano Si el cociente es ½, se redondea al núm</Descripción>
<ID>507</ID><Size>1491</Size><Creación>Fri Dec  8 10:21:37 2017</Creación><Descripción>La función ecvt() convierte number a una cadena terminada en NUL de ndigits dígitos, y devuelve un puntero a la cadena La cadena en si no contiene un punto decimal; sin embargo, la posición del punto </Descripción>
<ID>508</ID><Size>1784</Size><Creación>Fri Dec  8 10:21:38 2017</Creación><Descripción>La función getgrent() devuelve un puntero a una estructura que contiene la información de grupo de /etc/group La primera vez que se la llama devuelve la primera entrada; a partir de ahí devuelve las e</Descripción>
<ID>509</ID><Size>5598</Size><Creación>Fri Dec  8 10:21:38 2017</Creación><Descripción>La función gethostbyname() devuelve una estructura del tipo hostent para el anfitrión (host) dado name Aquí, name es ora un nombre de anfitrión, ora una dirección IPv4 en la notación normal de puntos,</Descripción>
<ID>510</ID><Size>3242</Size><Creación>Fri Dec  8 10:21:38 2017</Creación><Descripción>Estas rutinas se emplean para acceder al fichero que describe los sistemas de ficheros, /etc/fstab, y el que describe los sistemas de ficheros que están montados, /etc/mtab La función setmntent() abre</Descripción>
<ID>511</ID><Size>2657</Size><Creación>Fri Dec  8 10:21:38 2017</Creación><Descripción>La función getnetent() lee la línea siguiente del fichero /etc/networks y devuelve una estructura netent que contiene los campos descompuestos correspondientes a la línea El fichero /etc/networks se a</Descripción>
<ID>512</ID><Size>2520</Size><Creación>Fri Dec  8 10:21:38 2017</Creación><Descripción>La función getprotoent() lee la siguiente línea del fichero /etc/protocols y devuelve una estructura protoent que contiene los campos de que consta la línea El fichero /etc/protocols se abre si es nec</Descripción>
<ID>513</ID><Size>2022</Size><Creación>Fri Dec  8 10:21:38 2017</Creación><Descripción>La función getpwent() devuelve un puntero a una estructura que contiene los campos de una línea de /etc/passwd La primera vez que se la llama devuelve la primera entrada; a partir de ahí, devuelve las</Descripción>
<ID>514</ID><Size>2828</Size><Creación>Fri Dec  8 10:21:38 2017</Creación><Descripción>La función getservent() lee la siguiente línea del fichero /etc/services y devuelve una estructura servent que contiene en sus campos los campos de la línea Si es necesario, se abre el fichero /etc/se</Descripción>
<ID>515</ID><Size>1163</Size><Creación>Fri Dec  8 10:21:38 2017</Creación><Descripción>La función getusershell() devuelve la siguiente línea del fichero /etc/shells, abriéndolo si es necesario La línea debería contener la ruta de una shell de usuario válida Si /etc/shells no existe o no</Descripción>
<ID>516</ID><Size>4600</Size><Creación>Fri Dec  8 10:21:38 2017</Creación><Descripción>utmpname() establece qué nombre tiene el fichero en formato utmp al que van a acceder las otras funciones descritas aquí Si utmpname() no se llama para establecer el nombre de fichero antes de que se </Descripción>
<ID>517</ID><Size>4233</Size><Creación>Fri Dec  8 10:21:38 2017</Creación><Descripción>Estas funciones generan números seudo-aleatorios usando el algoritmo congruente lineal y artimética de enteros de 48 bits Las funciones drand48() y erand48() devuelven valores en coma flotante de dobl</Descripción>
<ID>518</ID><Size>672</Size><Creación>Fri Dec  8 10:21:38 2017</Creación><Descripción>La función erf() devuelve la función error de x; definida como erf(x) = 2/sqrt(pi)* integral desde 0 hasta x de exp(-t*t) dt La función erfc() devuelve la función error complementario de x, que es 1.0</Descripción>
<ID>519</ID><Size>672</Size><Creación>Fri Dec  8 10:21:38 2017</Creación><Descripción>La función erf() devuelve la función error de x; definida como erf(x) = 2/sqrt(pi)* integral desde 0 hasta x de exp(-t*t) dt La función erfc() devuelve la función error complementario de x, que es 1.0</Descripción>
<ID>520</ID><Size>4287</Size><Creación>Fri Dec  8 10:21:38 2017</Creación><Descripción>Algunas llamadas al sistema (y algunas funciones de biblioteca) dan un valor al entero errno para indicar qué ha ido mal Su valor sólo es significativo cuando la llamada devolvió un error (usualmente </Descripción>
<ID>521</ID><Size>5635</Size><Creación>Fri Dec  8 10:21:38 2017</Creación><Descripción>La familia de funciones exec reemplaza la imagen del proceso en curso con una nueva Las funciones descritas en esta página del Manual son interfaces para la primitiva execve(2) (Consulte la página del</Descripción>
<ID>522</ID><Size>5635</Size><Creación>Fri Dec  8 10:21:38 2017</Creación><Descripción>La familia de funciones exec reemplaza la imagen del proceso en curso con una nueva Las funciones descritas en esta página del Manual son interfaces para la primitiva execve(2) (Consulte la página del</Descripción>
<ID>523</ID><Size>5635</Size><Creación>Fri Dec  8 10:21:38 2017</Creación><Descripción>La familia de funciones exec reemplaza la imagen del proceso en curso con una nueva Las funciones descritas en esta página del Manual son interfaces para la primitiva execve(2) (Consulte la página del</Descripción>
<ID>524</ID><Size>5635</Size><Creación>Fri Dec  8 10:21:38 2017</Creación><Descripción>La familia de funciones exec reemplaza la imagen del proceso en curso con una nueva Las funciones descritas en esta página del Manual son interfaces para la primitiva execve(2) (Consulte la página del</Descripción>
<ID>525</ID><Size>5635</Size><Creación>Fri Dec  8 10:21:38 2017</Creación><Descripción>La familia de funciones exec reemplaza la imagen del proceso en curso con una nueva Las funciones descritas en esta página del Manual son interfaces para la primitiva execve(2) (Consulte la página del</Descripción>
<ID>526</ID><Size>5635</Size><Creación>Fri Dec  8 10:21:38 2017</Creación><Descripción>La familia de funciones exec reemplaza la imagen del proceso en curso con una nueva Las funciones descritas en esta página del Manual son interfaces para la primitiva execve(2) (Consulte la página del</Descripción>
<ID>527</ID><Size>796</Size><Creación>Fri Dec  8 10:21:38 2017</Creación><Descripción>La función exit produce la terminación normal del programa y la devolución de status al proceso padre Antes, se llama a todas las funciones registradas con atexit() y on_exit() en orden inverso a su r</Descripción>
<ID>528</ID><Size>1281</Size><Creación>Fri Dec  8 10:21:38 2017</Creación><Descripción>La función exp() devuelve el valor de e (la base de los logaritmos naturales) elevado a la potencia x La función log() devuelve el logaritmo neperiano de x La función log10() devuelve el logaritmo dec</Descripción>
<ID>529</ID><Size>882</Size><Creación>Fri Dec  8 10:21:38 2017</Creación><Descripción>expm1(x) devuelve un valor equivalente a `exp (x) - 1' Se computa de tal manera que es exacto incluso si el valor de x es cercano a cero: un caso donde `exp (x) - 1' sería inexacto debido a la sustrac</Descripción>
<ID>530</ID><Size>516</Size><Creación>Fri Dec  8 10:21:38 2017</Creación><Descripción>La función fabs() devuelve el valor absoluto del número en coma flotante x CONFORME A SVID 3, POSIX, BSD 4.3, ISO 9899 VÉASE TAMBIÉN abs(3), ceil(3), floor(3), labs(3), rint(3) 9 de Enero de 1998 FABS</Descripción>
<ID>531</ID><Size>1342</Size><Creación>Fri Dec  8 10:21:38 2017</Creación><Descripción>La función fclose disocia el flujo especificado de su fichero asociado o conjunto de funciones Si el flujo se estuvo empleando para salida, cualesquiera datos tamponados se escriben antes que nada, em</Descripción>
<ID>532</ID><Size>1491</Size><Creación>Fri Dec  8 10:21:38 2017</Creación><Descripción>La función ecvt() convierte number a una cadena terminada en NUL de ndigits dígitos, y devuelve un puntero a la cadena La cadena en si no contiene un punto decimal; sin embargo, la posición del punto </Descripción>
<ID>533</ID><Size>5519</Size><Creación>Fri Dec  8 10:21:38 2017</Creación><Descripción>La función fopen abre el fichero cuyo nombre es la cadena apuntada por camino y asocia un flujo de datos a él El argumento modo apunta a una cadena que empieza con una de las siguientes secuencias (a </Descripción>
<ID>534</ID><Size>1460</Size><Creación>Fri Dec  8 10:21:38 2017</Creación><Descripción>La función clearerr limpia los indicadores de fin-de- fichero y error para el flujo indicado por flujo La función feof inspecciona el indicador de fin-de-fichero para el flujo indicado por flujo, devo</Descripción>
<ID>535</ID><Size>1460</Size><Creación>Fri Dec  8 10:21:38 2017</Creación><Descripción>La función clearerr limpia los indicadores de fin-de- fichero y error para el flujo indicado por flujo La función feof inspecciona el indicador de fin-de-fichero para el flujo indicado por flujo, devo</Descripción>
<ID>536</ID><Size>1349</Size><Creación>Fri Dec  8 10:21:38 2017</Creación><Descripción>La función fflush fuerza una escritura de todos los datos tamponados para el flujo de salida dado, o actualiza el flujo a través de la función de escritura subyacente al flujo El estado de apertura de</Descripción>
<ID>537</ID><Size>691</Size><Creación>Fri Dec  8 10:21:38 2017</Creación><Descripción>La función ffs() devuelve la posición del primer bit puesto a 1 en la palabra i El bit menos significativo es el de la posición 1 y el más significativo el de la posición 32 VALOR DEVUELTO La función </Descripción>
<ID>538</ID><Size>3426</Size><Creación>Fri Dec  8 10:21:38 2017</Creación><Descripción>fgetc() lee el siguiente carácter de flujo y lo devuelve como un unsigned char modelado a un int, o EOF al llegar al final del flujo o en caso de error getc() es equivalente a fgetc() excepto en el he</Descripción>
<ID>539</ID><Size>1630</Size><Creación>Fri Dec  8 10:21:38 2017</Creación><Descripción>La función fgetgrent() devuelve un puntero a una estructura que contiene la información de grupos que está en el fichero correspondiente a flujo La primera vez que se la llama devuelve la primera entr</Descripción>
<ID>540</ID><Size>3015</Size><Creación>Fri Dec  8 10:21:38 2017</Creación><Descripción>La función fseek mueve el indicador de posición del fichero correspondiente al flujo de datos apuntado por flujo La nueva posición, medida en bytes, se obtiene añadiendo desplto bytes a la posición es</Descripción>
<ID>541</ID><Size>1980</Size><Creación>Fri Dec  8 10:21:38 2017</Creación><Descripción>La función fgetpwent() devuelve un puntero a una estructura que contiene los campos descompuestos de una línea del fichero correspondiente a flujo La primera vez que se la llama devuelve la primera en</Descripción>
<ID>542</ID><Size>3426</Size><Creación>Fri Dec  8 10:21:38 2017</Creación><Descripción>fgetc() lee el siguiente carácter de flujo y lo devuelve como un unsigned char modelado a un int, o EOF al llegar al final del flujo o en caso de error getc() es equivalente a fgetc() excepto en el he</Descripción>
<ID>543</ID><Size>1460</Size><Creación>Fri Dec  8 10:21:38 2017</Creación><Descripción>La función clearerr limpia los indicadores de fin-de- fichero y error para el flujo indicado por flujo La función feof inspecciona el indicador de fin-de-fichero para el flujo indicado por flujo, devo</Descripción>
<ID>544</ID><Size>881</Size><Creación>Fri Dec  8 10:21:38 2017</Creación><Descripción>La función isinf() devuelve -1 si valor representa infinito negativo, 1 si valor representa infinito positivo, y 0 en otro caso La función isnan() devuelve un valor distinto de cero si valor es "no-un</Descripción>
<ID>545</ID><Size>590</Size><Creación>Fri Dec  8 10:21:38 2017</Creación><Descripción>La función floor() redondea x hacia abajo al entero más cercano, devolviendo ese valor como un número en coma flotante de doble precisión (double) CONFORME A SVID 3, POSIX, BSD 4.3, ISO 9899 VÉASE TAM</Descripción>
<ID>546</ID><Size>803</Size><Creación>Fri Dec  8 10:21:38 2017</Creación><Descripción>La función fmod() computa el resto de la división de x entre y El valor devuelto es x - n * y, donde n es el cociente de x / y, redondeado a un entero hacia cero VALOR DEVUELTO La función fmod() devue</Descripción>
<ID>547</ID><Size>2686</Size><Creación>Fri Dec  8 10:21:38 2017</Creación><Descripción>La función fnmatch() comprueba si el argumento cadena concuerda con el argumento patron que es un patrón al estilo de los comodines del `shell' El argumento flags modifica el comportamiento; es el res</Descripción>
<ID>548</ID><Size>5519</Size><Creación>Fri Dec  8 10:21:38 2017</Creación><Descripción>La función fopen abre el fichero cuyo nombre es la cadena apuntada por camino y asocia un flujo de datos a él El argumento modo apunta a una cadena que empieza con una de las siguientes secuencias (a </Descripción>
<ID>549</ID><Size>4167</Size><Creación>Fri Dec  8 10:21:38 2017</Creación><Descripción>fpathconf() obtiene un valor para la opción de configuración nombre para el descriptor de fichero abierto descf pathconf() obtiene un valor para la opción de configuración nombre para el nombre de fic</Descripción>
<ID>550</ID><Size>16869</Size><Creación>Fri Dec  8 10:21:38 2017</Creación><Descripción>La familia de funciones printf produce una salida de acuerdo a format como se describe abajo Printf y vprintf escriben su salida a stdout, el flujo de salida estándar; fprintf y vfprintf escriben su s</Descripción>
<ID>551</ID><Size>2193</Size><Creación>Fri Dec  8 10:21:38 2017</Creación><Descripción>fputc() escribe el carácter c, modelado a un unsigned char, en flujo fputs() escribe la cadena de caracteres s en flujo, sin su terminador '\0' putc() es equivalente a fputc() salvo en que puede estar</Descripción>
<ID>552</ID><Size>2193</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>fputc() escribe el carácter c, modelado a un unsigned char, en flujo fputs() escribe la cadena de caracteres s en flujo, sin su terminador '\0' putc() es equivalente a fputc() salvo en que puede estar</Descripción>
<ID>553</ID><Size>1466</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>La función fread lee nmiemb elementos de datos, cada uno de tam bytes de largo, del flujo de datos apuntado por flujo, almacenándolos en el sitio apuntado por ptr La función fwrite escribe nmiemb elem</Descripción>
<ID>554</ID><Size>4258</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>calloc() asigna memoria para una matriz de nmemb elementos de size bytes cada uno y devuelve un puntero a la memoria asignada La memoria es puesta a cero malloc() asigna size bytes y devuelve un punte</Descripción>
<ID>555</ID><Size>5519</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>La función fopen abre el fichero cuyo nombre es la cadena apuntada por camino y asocia un flujo de datos a él El argumento modo apunta a una cadena que empieza con una de las siguientes secuencias (a </Descripción>
<ID>556</ID><Size>978</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>La función frexp() se emplea para dividir el número x en una fracción normalizada y un exponente que se guarda en *exp VALOR DEVUELTO La función frexp() devuelve la fracción normalizada Si el argument</Descripción>
<ID>557</ID><Size>12784</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>La familia scanf de funciones escudriña la entrada según un formato como se describe más adelante Este formato puede contener especificadores de conversión; los resultados de tales conversiones, si la</Descripción>
<ID>558</ID><Size>3015</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>La función fseek mueve el indicador de posición del fichero correspondiente al flujo de datos apuntado por flujo La nueva posición, medida en bytes, se obtiene añadiendo desplto bytes a la posición es</Descripción>
<ID>559</ID><Size>3015</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>La función fseek mueve el indicador de posición del fichero correspondiente al flujo de datos apuntado por flujo La nueva posición, medida en bytes, se obtiene añadiendo desplto bytes a la posición es</Descripción>
<ID>560</ID><Size>3015</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>La función fseek mueve el indicador de posición del fichero correspondiente al flujo de datos apuntado por flujo La nueva posición, medida en bytes, se obtiene añadiendo desplto bytes a la posición es</Descripción>
<ID>561</ID><Size>1443</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>Devuelve la hora y fecha actuales en pt, que se declara como sigue: struct timeb { time_t time; unsigned short millitm; short timezone; short dstflag; }; La estructura contiene la fecha desde `la époc</Descripción>
<ID>562</ID><Size>2051</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>La función convierte el nombre de camino de un fichero existente y accesible y un identificador de proyecto a una clave IPC de System V de tipo key_t VALOR DEVUELTO En caso de éxito el valor devuelto </Descripción>
<ID>563</ID><Size>2377</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>ftw() recorre un árbol de directorios empezando por el directorio indicado Para cada entrada encontrada en el árbol, llama a ptrfunc con el nombre de camino completo de la entrada, relativa a director</Descripción>
<ID>564</ID><Size>1466</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>La función fread lee nmiemb elementos de datos, cada uno de tam bytes de largo, del flujo de datos apuntado por flujo, almacenándolos en el sitio apuntado por ptr La función fwrite escribe nmiemb elem</Descripción>
<ID>565</ID><Size>791</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>La función gcvt() convierte numero a una cadena de caracteres ASCII con la mínima longitud posible, acabada en el carácter NUL, y guarda el resultado en buf Produce ndigit dígitos significativos en el</Descripción>
<ID>566</ID><Size>3426</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>fgetc() lee el siguiente carácter de flujo y lo devuelve como un unsigned char modelado a un int, o EOF al llegar al final del flujo o en caso de error getc() es equivalente a fgetc() excepto en el he</Descripción>
<ID>567</ID><Size>3426</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>fgetc() lee el siguiente carácter de flujo y lo devuelve como un unsigned char modelado a un int, o EOF al llegar al final del flujo o en caso de error getc() es equivalente a fgetc() excepto en el he</Descripción>
<ID>568</ID><Size>2404</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>La función getcwd() copia el nombre de camino absoluto del directorio de trabajo en curso al vector apuntado por buf, que tiene de longitud tam Si el nombre de camino absoluto antedicho requiriera un </Descripción>
<ID>569</ID><Size>1087</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>Lee entradas de directorio del especificado por fd y las guarda en el sitio apuntado por buf Como mucho se leen nbytes bytes La lectura empieza en la posición *pbase, y *pbase se actualiza con la nuev</Descripción>
<ID>570</ID><Size>772</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>La función getenv() busca en la lista de ambiente una cadena de caracteres que concuerde con la apuntada por nombre Las cadenas son de la forma nombre = valor VALOR DEVUELTO La función getenv() devuel</Descripción>
<ID>571</ID><Size>1784</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>La función getgrent() devuelve un puntero a una estructura que contiene la información de grupo de /etc/group La primera vez que se la llama devuelve la primera entrada; a partir de ahí devuelve las e</Descripción>
<ID>572</ID><Size>1737</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>La función getgrnam() devuelve un puntero a una estructura que contiene la información de grupos de /etc/group para la entrada que concuerde con el nombre de grupo nombre La función getgrgid() devuelv</Descripción>
<ID>573</ID><Size>1737</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>La función getgrnam() devuelve un puntero a una estructura que contiene la información de grupos de /etc/group para la entrada que concuerde con el nombre de grupo nombre La función getgrgid() devuelv</Descripción>
<ID>574</ID><Size>5598</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>La función gethostbyname() devuelve una estructura del tipo hostent para el anfitrión (host) dado name Aquí, name es ora un nombre de anfitrión, ora una dirección IPv4 en la notación normal de puntos,</Descripción>
<ID>575</ID><Size>5598</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>La función gethostbyname() devuelve una estructura del tipo hostent para el anfitrión (host) dado name Aquí, name es ora un nombre de anfitrión, ora una dirección IPv4 en la notación normal de puntos,</Descripción>
<ID>576</ID><Size>3222</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>getlogin devuelve un puntero a una cadena de caracteres que contiene el nombre del usuario que está en la terminal controladora del proceso, o un puntero nulo si esta información no puede determinarse</Descripción>
<ID>577</ID><Size>3242</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>Estas rutinas se emplean para acceder al fichero que describe los sistemas de ficheros, /etc/fstab, y el que describe los sistemas de ficheros que están montados, /etc/mtab La función setmntent() abre</Descripción>
<ID>578</ID><Size>2657</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>La función getnetent() lee la línea siguiente del fichero /etc/networks y devuelve una estructura netent que contiene los campos descompuestos correspondientes a la línea El fichero /etc/networks se a</Descripción>
<ID>579</ID><Size>2657</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>La función getnetent() lee la línea siguiente del fichero /etc/networks y devuelve una estructura netent que contiene los campos descompuestos correspondientes a la línea El fichero /etc/networks se a</Descripción>
<ID>580</ID><Size>2657</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>La función getnetent() lee la línea siguiente del fichero /etc/networks y devuelve una estructura netent que contiene los campos descompuestos correspondientes a la línea El fichero /etc/networks se a</Descripción>
<ID>581</ID><Size>10914</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>La función getopt() analiza los argumentos de la línea de órdenes Sus argumentos argc y argv son el número y el vector de argumentos como los pasados a la función main() cuando se ejecuta el programa </Descripción>
<ID>582</ID><Size>10914</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>La función getopt() analiza los argumentos de la línea de órdenes Sus argumentos argc y argv son el número y el vector de argumentos como los pasados a la función main() cuando se ejecuta el programa </Descripción>
<ID>583</ID><Size>10914</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>La función getopt() analiza los argumentos de la línea de órdenes Sus argumentos argc y argv son el número y el vector de argumentos como los pasados a la función main() cuando se ejecuta el programa </Descripción>
<ID>584</ID><Size>1721</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>La función getpass muestra un mensaje indicador en la salida estándar de errores, y lee una contraseña de /dev/tty Si este fichero no es accesible, getpass lee de la entrada estándar La contraseña pue</Descripción>
<ID>585</ID><Size>2520</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>La función getprotoent() lee la siguiente línea del fichero /etc/protocols y devuelve una estructura protoent que contiene los campos de que consta la línea El fichero /etc/protocols se abre si es nec</Descripción>
<ID>586</ID><Size>2520</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>La función getprotoent() lee la siguiente línea del fichero /etc/protocols y devuelve una estructura protoent que contiene los campos de que consta la línea El fichero /etc/protocols se abre si es nec</Descripción>
<ID>587</ID><Size>2520</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>La función getprotoent() lee la siguiente línea del fichero /etc/protocols y devuelve una estructura protoent que contiene los campos de que consta la línea El fichero /etc/protocols se abre si es nec</Descripción>
<ID>588</ID><Size>1738</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>La función getpw() reconstruye la línea del fichero de cuentas de usuario para el usuario cuyo UID se da como uid y el resultado se guarda en el sitio apuntado por buf El búfer devuelto en buf contien</Descripción>
<ID>589</ID><Size>2022</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>La función getpwent() devuelve un puntero a una estructura que contiene los campos de una línea de /etc/passwd La primera vez que se la llama devuelve la primera entrada; a partir de ahí, devuelve las</Descripción>
<ID>590</ID><Size>2006</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>La función getpwnam() devuelve un puntero a una estructura que contiene los campos de una línea de /etc/passwd para la entrada que concuerda con el nombre de usuario nombre La función getpwuid() devue</Descripción>
<ID>591</ID><Size>2006</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>La función getpwnam() devuelve un puntero a una estructura que contiene los campos de una línea de /etc/passwd para la entrada que concuerda con el nombre de usuario nombre La función getpwuid() devue</Descripción>
<ID>592</ID><Size>3426</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>fgetc() lee el siguiente carácter de flujo y lo devuelve como un unsigned char modelado a un int, o EOF al llegar al final del flujo o en caso de error getc() es equivalente a fgetc() excepto en el he</Descripción>
<ID>593</ID><Size>2828</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>La función getservent() lee la siguiente línea del fichero /etc/services y devuelve una estructura servent que contiene en sus campos los campos de la línea Si es necesario, se abre el fichero /etc/se</Descripción>
<ID>594</ID><Size>2828</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>La función getservent() lee la siguiente línea del fichero /etc/services y devuelve una estructura servent que contiene en sus campos los campos de la línea Si es necesario, se abre el fichero /etc/se</Descripción>
<ID>595</ID><Size>2828</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>La función getservent() lee la siguiente línea del fichero /etc/services y devuelve una estructura servent que contiene en sus campos los campos de la línea Si es necesario, se abre el fichero /etc/se</Descripción>
<ID>596</ID><Size>1163</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>La función getusershell() devuelve la siguiente línea del fichero /etc/shells, abriéndolo si es necesario La línea debería contener la ruta de una shell de usuario válida Si /etc/shells no existe o no</Descripción>
<ID>597</ID><Size>4600</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>utmpname() establece qué nombre tiene el fichero en formato utmp al que van a acceder las otras funciones descritas aquí Si utmpname() no se llama para establecer el nombre de fichero antes de que se </Descripción>
<ID>598</ID><Size>4600</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>utmpname() establece qué nombre tiene el fichero en formato utmp al que van a acceder las otras funciones descritas aquí Si utmpname() no se llama para establecer el nombre de fichero antes de que se </Descripción>
<ID>599</ID><Size>4600</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>utmpname() establece qué nombre tiene el fichero en formato utmp al que van a acceder las otras funciones descritas aquí Si utmpname() no se llama para establecer el nombre de fichero antes de que se </Descripción>
<ID>600</ID><Size>1146</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>getw lee una palabra (esto es, un int) de flujo Se suministra por compatibilidad con SVID Le recomendamos que emplee fread(3) en su lugar putw escribe la palabra p (esto es, un int) en flujo Se sumini</Descripción>
<ID>601</ID><Size>2404</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>La función getcwd() copia el nombre de camino absoluto del directorio de trabajo en curso al vector apuntado por buf, que tiene de longitud tam Si el nombre de camino absoluto antedicho requiriera un </Descripción>
<ID>602</ID><Size>2404</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>La función getcwd() copia el nombre de camino absoluto del directorio de trabajo en curso al vector apuntado por buf, que tiene de longitud tam Si el nombre de camino absoluto antedicho requiriera un </Descripción>
<ID>603</ID><Size>6457</Size><Creación>Fri Dec  8 10:21:39 2017</Creación><Descripción>La función glob() busca todos los nombres de camino de los ficheros que concuerden con patron según las reglas usadas por el interprete de comandos o shell No se realiza ni expansión de la tilde (~) n</Descripción>
<ID>604</ID><Size>6457</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>La función glob() busca todos los nombres de camino de los ficheros que concuerden con patron según las reglas usadas por el interprete de comandos o shell No se realiza ni expansión de la tilde (~) n</Descripción>
<ID>605</ID><Size>6099</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>La funciones ctime(), gmtime() y localtime() toman todas un argumento de tipo time_t que representa el tiempo de calendario Al ser interpretado como un valor de tiempo absoluto, representa el número d</Descripción>
<ID>606</ID><Size>5237</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>La rutina dbopen es la interfaz de biblioteca para los ficheros de bases de datos Uno de los formatos de fichero soportados es el de los ficheros dispersos La descripción general de los métodos de acc</Descripción>
<ID>607</ID><Size>3242</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>Estas rutinas se emplean para acceder al fichero que describe los sistemas de ficheros, /etc/fstab, y el que describe los sistemas de ficheros que están montados, /etc/mtab La función setmntent() abre</Descripción>
<ID>608</ID><Size>4362</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>Estas tres funciones permiten al usuario crear una tabla dispersa que asocia una clave con cualquier dato En primer lugar, se debe crear la tabla con la función hcreate() nel es una estimación del núm</Descripción>
<ID>609</ID><Size>4362</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>Estas tres funciones permiten al usuario crear una tabla dispersa que asocia una clave con cualquier dato En primer lugar, se debe crear la tabla con la función hcreate() nel es una estimación del núm</Descripción>
<ID>610</ID><Size>5598</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>La función gethostbyname() devuelve una estructura del tipo hostent para el anfitrión (host) dado name Aquí, name es ora un nombre de anfitrión, ora una dirección IPv4 en la notación normal de puntos,</Descripción>
<ID>611</ID><Size>4362</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>Estas tres funciones permiten al usuario crear una tabla dispersa que asocia una clave con cualquier dato En primer lugar, se debe crear la tabla con la función hcreate() nel es una estimación del núm</Descripción>
<ID>612</ID><Size>1480</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>La función htonl() convierte el entero largo hostlong desde el orden de bytes del host al de la red La función htons() convierte el entero corto hostshort desde el orden de bytes del host al de la red</Descripción>
<ID>613</ID><Size>1480</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>La función htonl() convierte el entero largo hostlong desde el orden de bytes del host al de la red La función htons() convierte el entero corto hostshort desde el orden de bytes del host al de la red</Descripción>
<ID>614</ID><Size>609</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>La función hypot() devuelve el resultado de sqrt(x*x + y*y) Este valor es la longitud de la hipotenusa de un triángulo rectángulo cuyos lados miden x e y, o la distancia del punto (x, y) al origen CON</Descripción>
<ID>615</ID><Size>1046</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>La función index() devuelve un puntero a la 1ª ocurrencia del carácter c en la cadena s La función rindex() devuelve un puntero a la última ocurrencia del carácter c en la cadena s El carácter cero (N</Descripción>
<ID>616</ID><Size>3475</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>inet_aton() convierte la dirección de Internet cp desde la notación estándar de números y puntos a la representación binaria, y la guarda en la estructura a la que apunte inp inet_aton devuelve no-cer</Descripción>
<ID>617</ID><Size>3475</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>inet_aton() convierte la dirección de Internet cp desde la notación estándar de números y puntos a la representación binaria, y la guarda en la estructura a la que apunte inp inet_aton devuelve no-cer</Descripción>
<ID>618</ID><Size>3475</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>inet_aton() convierte la dirección de Internet cp desde la notación estándar de números y puntos a la representación binaria, y la guarda en la estructura a la que apunte inp inet_aton devuelve no-cer</Descripción>
<ID>619</ID><Size>3475</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>inet_aton() convierte la dirección de Internet cp desde la notación estándar de números y puntos a la representación binaria, y la guarda en la estructura a la que apunte inp inet_aton devuelve no-cer</Descripción>
<ID>620</ID><Size>3475</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>inet_aton() convierte la dirección de Internet cp desde la notación estándar de números y puntos a la representación binaria, y la guarda en la estructura a la que apunte inp inet_aton devuelve no-cer</Descripción>
<ID>621</ID><Size>3475</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>inet_aton() convierte la dirección de Internet cp desde la notación estándar de números y puntos a la representación binaria, y la guarda en la estructura a la que apunte inp inet_aton devuelve no-cer</Descripción>
<ID>622</ID><Size>3475</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>inet_aton() convierte la dirección de Internet cp desde la notación estándar de números y puntos a la representación binaria, y la guarda en la estructura a la que apunte inp inet_aton devuelve no-cer</Descripción>
<ID>623</ID><Size>965</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>La función infnan() devuelve un valor manejable para un valor infinito o no-numérico (NaN) El valor de error puede ser ERANGE para representar infinito, o cualquier otro valor para NaN errno también s</Descripción>
<ID>624</ID><Size>1123</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>La función initgroups() inicializa la lista de acceso de grupos leyendo la base de datos de grupos /etc/group y usando todos los grupos de los que user es miembro Se añade a la lista el grupo adiciona</Descripción>
<ID>625</ID><Size>3059</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>La función random() emplea un generador no lineal aditivo con retroalimentación de números aleatorios utilizando una tabla predeterminada de 31 enteros largos para devolver números pseudo-aleatorios s</Descripción>
<ID>626</ID><Size>1682</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>insque() y remque() son funciones para manipular colas hechas a partir de listas doblemente enlazadas Cada elemento en esta lista es de tipo struct qelem La estructura qelem se define como struct qele</Descripción>
<ID>627</ID><Size>1811</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>Esta sección describe todas las funciones de biblioteca, excluyendo las descritas en la sección 2, que implementan las llamadas al sistema Hay varios grupos de funciones que pueden identificarse con u</Descripción>
<ID>628</ID><Size>5517</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>La función rcmd es utilizada por el superusuario para ejecutar una orden en una máquina remota usando un esquema de autenticación basado en números de puertos reservados La función rresvport devuelve </Descripción>
<ID>629</ID><Size>3881</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>Estas funciones comprueban si c, que debe tener el valor de un unsigned char o EOF, cae dentro de una cierta clase de caracteres de acuerdo con la localización en curso isalnum() comprueba si el carác</Descripción>
<ID>630</ID><Size>3881</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>Estas funciones comprueban si c, que debe tener el valor de un unsigned char o EOF, cae dentro de una cierta clase de caracteres de acuerdo con la localización en curso isalnum() comprueba si el carác</Descripción>
<ID>631</ID><Size>3881</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>Estas funciones comprueban si c, que debe tener el valor de un unsigned char o EOF, cae dentro de una cierta clase de caracteres de acuerdo con la localización en curso isalnum() comprueba si el carác</Descripción>
<ID>632</ID><Size>508</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>Devuelve 1 si desc es un descriptor abierto conectado a una terminal y 0 en otro caso CONFORME A SVID, AT&T, X/OPEN, BSD 4.3 VÉASE TAMBIÉN fstat(2), ttyname(3) Linux 2 Marzo 1998 ISATTY(3) </Descripción>
<ID>633</ID><Size>3881</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>Estas funciones comprueban si c, que debe tener el valor de un unsigned char o EOF, cae dentro de una cierta clase de caracteres de acuerdo con la localización en curso isalnum() comprueba si el carác</Descripción>
<ID>634</ID><Size>3881</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>Estas funciones comprueban si c, que debe tener el valor de un unsigned char o EOF, cae dentro de una cierta clase de caracteres de acuerdo con la localización en curso isalnum() comprueba si el carác</Descripción>
<ID>635</ID><Size>3881</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>Estas funciones comprueban si c, que debe tener el valor de un unsigned char o EOF, cae dentro de una cierta clase de caracteres de acuerdo con la localización en curso isalnum() comprueba si el carác</Descripción>
<ID>636</ID><Size>3881</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>Estas funciones comprueban si c, que debe tener el valor de un unsigned char o EOF, cae dentro de una cierta clase de caracteres de acuerdo con la localización en curso isalnum() comprueba si el carác</Descripción>
<ID>637</ID><Size>881</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>La función isinf() devuelve -1 si valor representa infinito negativo, 1 si valor representa infinito positivo, y 0 en otro caso La función isnan() devuelve un valor distinto de cero si valor es "no-un</Descripción>
<ID>638</ID><Size>3881</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>Estas funciones comprueban si c, que debe tener el valor de un unsigned char o EOF, cae dentro de una cierta clase de caracteres de acuerdo con la localización en curso isalnum() comprueba si el carác</Descripción>
<ID>639</ID><Size>881</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>La función isinf() devuelve -1 si valor representa infinito negativo, 1 si valor representa infinito positivo, y 0 en otro caso La función isnan() devuelve un valor distinto de cero si valor es "no-un</Descripción>
<ID>640</ID><Size>3881</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>Estas funciones comprueban si c, que debe tener el valor de un unsigned char o EOF, cae dentro de una cierta clase de caracteres de acuerdo con la localización en curso isalnum() comprueba si el carác</Descripción>
<ID>641</ID><Size>3881</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>Estas funciones comprueban si c, que debe tener el valor de un unsigned char o EOF, cae dentro de una cierta clase de caracteres de acuerdo con la localización en curso isalnum() comprueba si el carác</Descripción>
<ID>642</ID><Size>3881</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>Estas funciones comprueban si c, que debe tener el valor de un unsigned char o EOF, cae dentro de una cierta clase de caracteres de acuerdo con la localización en curso isalnum() comprueba si el carác</Descripción>
<ID>643</ID><Size>3881</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>Estas funciones comprueban si c, que debe tener el valor de un unsigned char o EOF, cae dentro de una cierta clase de caracteres de acuerdo con la localización en curso isalnum() comprueba si el carác</Descripción>
<ID>644</ID><Size>3881</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>Estas funciones comprueban si c, que debe tener el valor de un unsigned char o EOF, cae dentro de una cierta clase de caracteres de acuerdo con la localización en curso isalnum() comprueba si el carác</Descripción>
<ID>645</ID><Size>1276</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>Las funciones j0() y j1() devuelven las funciones de Bessel de x de primera clase de órdenes 0 y 1, respectivamente La función jn() devuelve la función de Bessel de x de primera clase de orden n Las f</Descripción>
<ID>646</ID><Size>1276</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>Las funciones j0() y j1() devuelven las funciones de Bessel de x de primera clase de órdenes 0 y 1, respectivamente La función jn() devuelve la función de Bessel de x de primera clase de orden n Las f</Descripción>
<ID>647</ID><Size>1276</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>Las funciones j0() y j1() devuelven las funciones de Bessel de x de primera clase de órdenes 0 y 1, respectivamente La función jn() devuelve la función de Bessel de x de primera clase de orden n Las f</Descripción>
<ID>648</ID><Size>4233</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>Estas funciones generan números seudo-aleatorios usando el algoritmo congruente lineal y artimética de enteros de 48 bits Las funciones drand48() y erand48() devuelven valores en coma flotante de dobl</Descripción>
<ID>649</ID><Size>1218</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>La función killpg() hace que se envíe la señal signal a todos los procesos del grupo de procesos pidgrp o a los procesos del propio grupo de procesos si pidgrp es igual a cero Es equivalente a kill(-p</Descripción>
<ID>650</ID><Size>739</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>La función labs() computa el valor absoluto del argumento j, que es un entero largo VALOR DEVUELTO Devuelve el valor absoluto del argumento, que es un entero largo CONFORME A SVID 3, BSD 4.3, ISO 9899</Descripción>
<ID>651</ID><Size>4233</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>Estas funciones generan números seudo-aleatorios usando el algoritmo congruente lineal y artimética de enteros de 48 bits Las funciones drand48() y erand48() devuelven valores en coma flotante de dobl</Descripción>
<ID>652</ID><Size>566</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>La función ldexp() devuelve el resultado de multiplicar el número en coma flotante x por 2 elevado a exp CONFORME A SVID 3, POSIX, BSD 4.3, ISO 9899 VÉASE TAMBIÉN frexp(3), modf(3) BSD 2 Marzo 1998 LD</Descripción>
<ID>653</ID><Size>710</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>La función ldiv() computa el valor numer÷denom y devuelve el cociente y el resto en una estructura llamada ldiv_t que contiene dos miembros que son enteros largos y que se llaman quot y rem VALOR DEVU</Descripción>
<ID>654</ID><Size>1535</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>lfind() y lsearch() realizan una búsqueda lineal de key en la matriz base que tiene *nmemb elementos de size bytes cada uno Se espera que la función de comparación a que hace referencia compar tenga d</Descripción>
<ID>655</ID><Size>733</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>La función lgamma() devuelve el logaritmo del valor absoluto de la función Gamma El signo de la función Gamma se devuelve en el entero externo signgam Para valores enteros negativos de x, lgamma() dev</Descripción>
<ID>656</ID><Size>1079</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>La función localeconv() devuelve un puntero a una struct lconv para la localización en curso Esta estructura se define en el fichero cabecera locale.h y contiene todos los valores asociados con las ca</Descripción>
<ID>657</ID><Size>6099</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>La funciones ctime(), gmtime() y localtime() toman todas un argumento de tipo time_t que representa el tiempo de calendario Al ser interpretado como un valor de tiempo absoluto, representa el número d</Descripción>
<ID>658</ID><Size>1281</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>La función exp() devuelve el valor de e (la base de los logaritmos naturales) elevado a la potencia x La función log() devuelve el logaritmo neperiano de x La función log10() devuelve el logaritmo dec</Descripción>
<ID>659</ID><Size>1281</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>La función exp() devuelve el valor de e (la base de los logaritmos naturales) elevado a la potencia x La función log() devuelve el logaritmo neperiano de x La función log10() devuelve el logaritmo dec</Descripción>
<ID>660</ID><Size>882</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>expm1(x) devuelve un valor equivalente a `exp (x) - 1' Se computa de tal manera que es exacto incluso si el valor de x es cercano a cero: un caso donde `exp (x) - 1' sería inexacto debido a la sustrac</Descripción>
<ID>661</ID><Size>1055</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>updwtmp() añade la estructura utmp ut al fichero wtmp logwtmp() crea una estructura utmp utilizando línea, nombre, host, instante de tiempo actual e identificador del proceso actual A continuación, ll</Descripción>
<ID>662</ID><Size>1903</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>longjmp() y setjmp() son útiles para tratar con errores e interrupciones encontrados en una subrutina de bajo nivel de un programa longjmp() restaura el entorno salvaguardado por la última llamada a s</Descripción>
<ID>663</ID><Size>4233</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>Estas funciones generan números seudo-aleatorios usando el algoritmo congruente lineal y artimética de enteros de 48 bits Las funciones drand48() y erand48() devuelven valores en coma flotante de dobl</Descripción>
<ID>664</ID><Size>1535</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>lfind() y lsearch() realizan una búsqueda lineal de key en la matriz base que tiene *nmemb elementos de size bytes cada uno Se espera que la función de comparación a que hace referencia compar tenga d</Descripción>
<ID>665</ID><Size>4258</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>calloc() asigna memoria para una matriz de nmemb elementos de size bytes cada uno y devuelve un puntero a la memoria asignada La memoria es puesta a cero malloc() asigna size bytes y devuelve un punte</Descripción>
<ID>666</ID><Size>902</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>La función mblen() recorre los primeros n bytes de la cadena de caracteres s y devuelve el número de bytes en un carácter La función mblen() es equivalente a mbtowc((wchat_t *)0, s, n); salvo en que e</Descripción>
<ID>667</ID><Size>841</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>La función mbstowcs() convierte una secuencia de caracteres multibyte del vector s a una secuencia de caracteres anchos y guarda hasta n caracteres anchos en el vector pwcs VALOR DEVUELTO mbstowcs() d</Descripción>
<ID>668</ID><Size>791</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>La función mbtowc() convierte un carácter multibyte s, que no es mayor de n bytes, en un carácter ancho y, si pwc no es NULL, guarda dicho carácter ancho en *pwc VALOR DEVUELTO mbtowc() devuelve el nú</Descripción>
<ID>669</ID><Size>808</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>La función memccpy() copia como mucho n bytes desde el área de memoria orig al área de memoria dest, parando cuando se encuentra el carácter c VALOR DEVUELTO La función memccpy() devuelve un puntero a</Descripción>
<ID>670</ID><Size>919</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>La función memchr() rastrea los primeros n bytes del área de memoria apuntada por s buscando el carácter c La operación acaba al llegarse al primer byte que concuerde con c (interpretado como un carác</Descripción>
<ID>671</ID><Size>869</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>La funcion memcmp() compara los primeros n bytes de las areas de memoria s1 y s2 Devuelve un entero menor, igual a o mayor que cero si s1 es, respectivamente, menor, igual o mayor que s2 VALOR DEVUELT</Descripción>
<ID>672</ID><Size>761</Size><Creación>Fri Dec  8 10:21:40 2017</Creación><Descripción>La funcion memcpy() copia n bytes desde el area de memoria src al area dest Dichas areas de memoria no deben tener ningun punto de interseccion; en tal caso utilizar la funcion memmove(3) en lugar de </Descripción>
<ID>673</ID><Size>1067</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>La función memfrob() cifra los primeros n bytes de la zona de memoria s haciendo un XOR (O exclusivo) de cada carácter con el número 42 El efecto puede invertirse empleando de nuevo memfrob() en la zo</Descripción>
<ID>674</ID><Size>1561</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>La función memmem() busca el principio de la primera ocurrencia de la subcadena needle de longitud needlelen en el área de memoria haystack de longitud haystacklen VALOR DEVUELTO La función memmem() d</Descripción>
<ID>675</ID><Size>673</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>La función memmove() copia n bytes del área de memoria src al área de memoria dest Las áreas de memoria pueden solaparse VALOR DEVUELTO La función memmove() devuelve un puntero a dest CONFORME A SVID </Descripción>
<ID>676</ID><Size>637</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>La función memset() rellena los primeros n bytes del área de memoria apuntada por s con el byte constante c VALOR DEVUELTO La función memset() devuelve un puntero al área de memoria s CONFORME A SVID </Descripción>
<ID>677</ID><Size>2892</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>mkfifo construye un fichero especial FIFO con el nombre camino modo especifica los permisos del FIFO Son modificados por la máscara umask del proceso de la forma habitual: los permisos del fichero rec</Descripción>
<ID>678</ID><Size>2032</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>La función mkstemp() genera un nombre de fichero temporal único a partir de template Los últimos seis caracteres de template deben ser XXXXXX y éstos son reemplazados con una cadena que hace que el no</Descripción>
<ID>679</ID><Size>2167</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>La función mktemp() genera un nombre de fichero temporal único a partir de template Los últimos seis caracteres de template deben ser XXXXXX y éstos son reemplazados con una cadena que hace que el nom</Descripción>
<ID>680</ID><Size>6099</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>La funciones ctime(), gmtime() y localtime() toman todas un argumento de tipo time_t que representa el tiempo de calendario Al ser interpretado como un valor de tiempo absoluto, representa el número d</Descripción>
<ID>681</ID><Size>771</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>La función modf() divide el argumento x en una parte entera y una parte fraccional, cada una de las cuales tiene el mismo signo que x La parte entera se guarda en el sitio apuntado por iptr VALOR DEVU</Descripción>
<ID>682</ID><Size>5459</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>Mpool es la interfaz de biblioteca destinada a proporcionar un manejo de buffers de fichero orientado a páginas Los buffers pueden ser compartidos entre procesos La función mpool_open inicializa un de</Descripción>
<ID>683</ID><Size>4233</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>Estas funciones generan números seudo-aleatorios usando el algoritmo congruente lineal y artimética de enteros de 48 bits Las funciones drand48() y erand48() devuelven valores en coma flotante de dobl</Descripción>
<ID>684</ID><Size>2687</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>netlink.h define varias macros estándares para acceder o crear un datagrama netlink En esencia son similares a las macros definidas en cmsg(3) para los datos auxiliares Se debería acceder al buffer pa</Descripción>
<ID>685</ID><Size>4233</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>Estas funciones generan números seudo-aleatorios usando el algoritmo congruente lineal y artimética de enteros de 48 bits Las funciones drand48() y erand48() devuelven valores en coma flotante de dobl</Descripción>
<ID>686</ID><Size>1480</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>La función htonl() convierte el entero largo hostlong desde el orden de bytes del host al de la red La función htons() convierte el entero corto hostshort desde el orden de bytes del host al de la red</Descripción>
<ID>687</ID><Size>1480</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>La función htonl() convierte el entero largo hostlong desde el orden de bytes del host al de la red La función htons() convierte el entero corto hostshort desde el orden de bytes del host al de la red</Descripción>
<ID>688</ID><Size>867</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>La función on_exit() registra la funcion dada para ser invocada en la terminación normal de un programa, ya sea vía exit(3) o vía el valor retornado por la función main del programa A la funcion se le</Descripción>
<ID>689</ID><Size>1280</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>La función opendir() abre un flujo de directorio correspondiente al directorio nombre, y devuelve un puntero al flujo de directorio El flujo se sitúa en la primera entrada del directorio VALOR DEVUELT</Descripción>
<ID>690</ID><Size>4457</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>closelog() cierra el descriptor que se esté usando para escribir en el registrador del sistema El empleo de closelog() es opcional openlog() abre, para un programa, una conexión con el registrador del</Descripción>
<ID>691</ID><Size>4167</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>fpathconf() obtiene un valor para la opción de configuración nombre para el descriptor de fichero abierto descf pathconf() obtiene un valor para la opción de configuración nombre para el nombre de fic</Descripción>
<ID>692</ID><Size>3777</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>La función popen() inicia un proceso creando una tubería, llamando a fork(2) para crear el proceso y ejecutando el intérprete de comandos (shell) Puesto que una tubería es unidireccional por definició</Descripción>
<ID>693</ID><Size>2527</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>La rutina perror() produce un mensaje que va a la salida estándar de errores, describiendo el último error encontrado durante una llamada al sistema o a ciertas funciones de biblioteca La cadena de ca</Descripción>
<ID>694</ID><Size>3777</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>La función popen() inicia un proceso creando una tubería, llamando a fork(2) para crear el proceso y ejecutando el intérprete de comandos (shell) Puesto que una tubería es unidireccional por definició</Descripción>
<ID>695</ID><Size>1281</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>La función exp() devuelve el valor de e (la base de los logaritmos naturales) elevado a la potencia x La función log() devuelve el logaritmo neperiano de x La función log10() devuelve el logaritmo dec</Descripción>
<ID>696</ID><Size>16869</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>La familia de funciones printf produce una salida de acuerdo a format como se describe abajo Printf y vprintf escriben su salida a stdout, el flujo de salida estándar; fprintf y vfprintf escriben su s</Descripción>
<ID>697</ID><Size>1358</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>Esta rutina proporciona un medio para averiguar en qué partes su programa pasa la mayor parte de su tiempo El argumento buf apunta a tambuf bytes de memoria Cada 10 milisegundos virtuales, se examina </Descripción>
<ID>698</ID><Size>976</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>La función psignal() muestra un mensaje en stderr consistente en la cadena de caracteres s, un signo de dos puntos, un espacio en blanco, y una cadena de caracteres que describe el número de señal sig</Descripción>
<ID>699</ID><Size>2193</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>fputc() escribe el carácter c, modelado a un unsigned char, en flujo fputs() escribe la cadena de caracteres s en flujo, sin su terminador '\0' putc() es equivalente a fputc() salvo en que puede estar</Descripción>
<ID>700</ID><Size>2193</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>fputc() escribe el carácter c, modelado a un unsigned char, en flujo fputs() escribe la cadena de caracteres s en flujo, sin su terminador '\0' putc() es equivalente a fputc() salvo en que puede estar</Descripción>
<ID>701</ID><Size>960</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>La función putenv() añade o cambia el valor de variables de entorno o ambiente El argumento cadena es de la forma nombre=valor Si nombre no existe ya en el ambiente, entonces cadena se añade al entorn</Descripción>
<ID>702</ID><Size>1397</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>La función putpwent() escribe una entrada de usuario de la estructura p en el fichero asociado con flujo La estructura passwd se define en <pwd.h> así: struct passwd { char *pw_name; /* nombre de usua</Descripción>
<ID>703</ID><Size>2193</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>fputc() escribe el carácter c, modelado a un unsigned char, en flujo fputs() escribe la cadena de caracteres s en flujo, sin su terminador '\0' putc() es equivalente a fputc() salvo en que puede estar</Descripción>
<ID>704</ID><Size>4600</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>utmpname() establece qué nombre tiene el fichero en formato utmp al que van a acceder las otras funciones descritas aquí Si utmpname() no se llama para establecer el nombre de fichero antes de que se </Descripción>
<ID>705</ID><Size>1146</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>getw lee una palabra (esto es, un int) de flujo Se suministra por compatibilidad con SVID Le recomendamos que emplee fread(3) en su lugar putw escribe la palabra p (esto es, un int) en flujo Se sumini</Descripción>
<ID>706</ID><Size>1223</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>La función qsort() ordena un vector de nmiemb elementos de tamaño tam El argumento base apunta al comienzo del vector Los contenidos del vector se clasifican en orden ascendente de acuerdo a una funci</Descripción>
<ID>707</ID><Size>568</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>La función raise envía la señal sig al proceso en curso Es equivalente a kill(getpid(),sig) VALOR DEVUELTO 0 en caso de éxito, no-cero si falla CONFORME A C ANSI VÉASE TAMBIÉN kill(2), signal(2), getp</Descripción>
<ID>708</ID><Size>2938</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>La función rand() devuelve un entero pseudo-aleatorio entre 0 y RAND_MAX La función srand() establece su argumento como la semilla de una nueva serie de enteros seudo-aleatorios que serán devueltos en</Descripción>
<ID>709</ID><Size>3059</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>La función random() emplea un generador no lineal aditivo con retroalimentación de números aleatorios utilizando una tabla predeterminada de 31 enteros largos para devolver números pseudo-aleatorios s</Descripción>
<ID>710</ID><Size>5517</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>La función rcmd es utilizada por el superusuario para ejecutar una orden en una máquina remota usando un esquema de autenticación basado en números de puertos reservados La función rresvport devuelve </Descripción>
<ID>711</ID><Size>2077</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>La función readdir() devuelve un puntero a una estructura dirent que representa la siguiente entrada de directorio en el flujo de directorio al que apunte dir Devuelve NULL cuando alcanza el fin-de-fi</Descripción>
<ID>712</ID><Size>2602</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>La función readv() lee num bloques del fichero asociado con el descriptor de fichero descfic en los múltiples búferes descritos por vector La función writev() escribe como mucho num bloques descritos </Descripción>
<ID>713</ID><Size>4258</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>calloc() asigna memoria para una matriz de nmemb elementos de size bytes cada uno y devuelve un puntero a la memoria asignada La memoria es puesta a cero malloc() asigna size bytes y devuelve un punte</Descripción>
<ID>714</ID><Size>1952</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>realpath expande todos los enlaces simbólicos y resuelve referencias a '/./', '/ /' y los caracteres extra '/' en la cadena de caracteres terminada en cero especificada por camino y guarda el camino a</Descripción>
<ID>715</ID><Size>7948</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>La ruinta dbopen es la interfaz de biblioteca para los ficheros de bases de datos Uno de los formatos de fichero soportados es el de los ficheros con registros numerados (que llamaremos regnum) La des</Descripción>
<ID>716</ID><Size>8499</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>--NO POSEE DESCRIPCIÓN--</Descripción>
<ID>717</ID><Size>8499</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>--NO POSEE DESCRIPCIÓN--</Descripción>
<ID>718</ID><Size>8499</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>--NO POSEE DESCRIPCIÓN--</Descripción>
<ID>719</ID><Size>8499</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>--NO POSEE DESCRIPCIÓN--</Descripción>
<ID>720</ID><Size>8499</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>--NO POSEE DESCRIPCIÓN--</Descripción>
<ID>721</ID><Size>2988</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>remove borra un nombre del sistema de ficheros La función llama a unlink para ficheros y a rmdir para directorios Si el nombre borrado es el último enlace a un fichero y este no está abierto por ningú</Descripción>
<ID>722</ID><Size>1682</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>insque() y remque() son funciones para manipular colas hechas a partir de listas doblemente enlazadas Cada elemento en esta lista es de tipo struct qelem La estructura qelem se define como struct qele</Descripción>
<ID>723</ID><Size>7185</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>Estas funciones hacen peticiones e interpretan las respuestas de los servidores de nombres de dominio de Internet La función res_init() lee los ficheros de configuración (ver resolv+(8)) para consegui</Descripción>
<ID>724</ID><Size>7185</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>Estas funciones hacen peticiones e interpretan las respuestas de los servidores de nombres de dominio de Internet La función res_init() lee los ficheros de configuración (ver resolv+(8)) para consegui</Descripción>
<ID>725</ID><Size>7185</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>Estas funciones hacen peticiones e interpretan las respuestas de los servidores de nombres de dominio de Internet La función res_init() lee los ficheros de configuración (ver resolv+(8)) para consegui</Descripción>
<ID>726</ID><Size>7185</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>Estas funciones hacen peticiones e interpretan las respuestas de los servidores de nombres de dominio de Internet La función res_init() lee los ficheros de configuración (ver resolv+(8)) para consegui</Descripción>
<ID>727</ID><Size>7185</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>Estas funciones hacen peticiones e interpretan las respuestas de los servidores de nombres de dominio de Internet La función res_init() lee los ficheros de configuración (ver resolv+(8)) para consegui</Descripción>
<ID>728</ID><Size>7185</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>Estas funciones hacen peticiones e interpretan las respuestas de los servidores de nombres de dominio de Internet La función res_init() lee los ficheros de configuración (ver resolv+(8)) para consegui</Descripción>
<ID>729</ID><Size>7185</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>Estas funciones hacen peticiones e interpretan las respuestas de los servidores de nombres de dominio de Internet La función res_init() lee los ficheros de configuración (ver resolv+(8)) para consegui</Descripción>
<ID>730</ID><Size>3015</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>La función fseek mueve el indicador de posición del fichero correspondiente al flujo de datos apuntado por flujo La nueva posición, medida en bytes, se obtiene añadiendo desplto bytes a la posición es</Descripción>
<ID>731</ID><Size>697</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>La función rewinddir() reinicia la posición del flujo de directorio dir, poniéndola al principio del directorio VALOR REGRESADO La función rewinddir() no devuelve ningún valor CONFORME A SVID 3, POSIX</Descripción>
<ID>732</ID><Size>1255</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>re_comp se emplea para compilar la expresión regular terminada en cero a la que apunte exreg El patrón compilado ocupa un área estática, el búfer del patrón, que se sobreescribirá en la próxima llamad</Descripción>
<ID>733</ID><Size>1255</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>re_comp se emplea para compilar la expresión regular terminada en cero a la que apunte exreg El patrón compilado ocupa un área estática, el búfer del patrón, que se sobreescribirá en la próxima llamad</Descripción>
<ID>734</ID><Size>1046</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>La función index() devuelve un puntero a la 1ª ocurrencia del carácter c en la cadena s La función rindex() devuelve un puntero a la última ocurrencia del carácter c en la cadena s El carácter cero (N</Descripción>
<ID>735</ID><Size>689</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>La función rint() redondea x a un valor entero de acuerdo con el modo prevaleciente de redondeo El modo de redondeo por defecto es redondear al entero más cercano VALOR REGRESADO La función rint() dev</Descripción>
<ID>736</ID><Size>5517</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>La función rcmd es utilizada por el superusuario para ejecutar una orden en una máquina remota usando un esquema de autenticación basado en números de puertos reservados La función rresvport devuelve </Descripción>
<ID>737</ID><Size>3226</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>Todos los mensajes rtnetlink(7) están formados por una cabecera de mensaje netlink(7) y atributos añadidos Los atributos sólo deberían ser manipulados usando las macros suministradas aquí RTA_OK(rta, </Descripción>
<ID>738</ID><Size>5517</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>La función rcmd es utilizada por el superusuario para ejecutar una orden en una máquina remota usando un esquema de autenticación basado en números de puertos reservados La función rresvport devuelve </Descripción>
<ID>739</ID><Size>2310</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>La función scandir() rastrea el directorio dir, llamando select() en cada entrada de directorio Las entradas para las que select() devuelve un valor distinto de cero se almacenan en cadenas (strings) </Descripción>
<ID>740</ID><Size>12784</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>La familia scanf de funciones escudriña la entrada según un formato como se describe más adelante Este formato puede contener especificadores de conversión; los resultados de tales conversiones, si la</Descripción>
<ID>741</ID><Size>4233</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>Estas funciones generan números seudo-aleatorios usando el algoritmo congruente lineal y artimética de enteros de 48 bits Las funciones drand48() y erand48() devuelven valores en coma flotante de dobl</Descripción>
<ID>742</ID><Size>844</Size><Creación>Fri Dec  8 10:21:41 2017</Creación><Descripción>La función seekdir() determina la localización en el flujo de directorio a partir de la cual empezará la próxima llamada a readdir() seekdir() debería ser usado con un desplazamiento devuelto por tell</Descripción>
<ID>743</ID><Size>4241</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>Los tres tipos disponibles de estrategias de asignación de búferes son sin búfer, con búfer de bloque, y con búfer de línea Cuando un flujo de salida está sin búfer, la información aparece en el fiche</Descripción>
<ID>744</ID><Size>4241</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>Los tres tipos disponibles de estrategias de asignación de búferes son sin búfer, con búfer de bloque, y con búfer de línea Cuando un flujo de salida está sin búfer, la información aparece en el fiche</Descripción>
<ID>745</ID><Size>1048</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función setenv() añade la variable nombre al entorno o ambiente con el valor valor, si nombre no existe ya Si nombre sí existe ya en el ambiente, entonces su valor se cambia a valor si sobrescribir</Descripción>
<ID>746</ID><Size>1784</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función getgrent() devuelve un puntero a una estructura que contiene la información de grupo de /etc/group La primera vez que se la llama devuelve la primera entrada; a partir de ahí devuelve las e</Descripción>
<ID>747</ID><Size>5598</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función gethostbyname() devuelve una estructura del tipo hostent para el anfitrión (host) dado name Aquí, name es ora un nombre de anfitrión, ora una dirección IPv4 en la notación normal de puntos,</Descripción>
<ID>748</ID><Size>1670</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>Las funciones setjmp() y longjmp() son útiles para tratar con errores e interrupciones encontradas en una subrutina de bajo nivel de un programa setjmp() guarda el entorno/contexto de pila en env para</Descripción>
<ID>749</ID><Size>4241</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>Los tres tipos disponibles de estrategias de asignación de búferes son sin búfer, con búfer de bloque, y con búfer de línea Cuando un flujo de salida está sin búfer, la información aparece en el fiche</Descripción>
<ID>750</ID><Size>3338</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función setlocale() se emplea para establecer o saber la localización en curso en el programa Si localizacion es "C" o "POSIX", la localización en curso se establece como la localización transporta</Descripción>
<ID>751</ID><Size>3242</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>Estas rutinas se emplean para acceder al fichero que describe los sistemas de ficheros, /etc/fstab, y el que describe los sistemas de ficheros que están montados, /etc/mtab La función setmntent() abre</Descripción>
<ID>752</ID><Size>2657</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función getnetent() lee la línea siguiente del fichero /etc/networks y devuelve una estructura netent que contiene los campos descompuestos correspondientes a la línea El fichero /etc/networks se a</Descripción>
<ID>753</ID><Size>2520</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función getprotoent() lee la siguiente línea del fichero /etc/protocols y devuelve una estructura protoent que contiene los campos de que consta la línea El fichero /etc/protocols se abre si es nec</Descripción>
<ID>754</ID><Size>2022</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función getpwent() devuelve un puntero a una estructura que contiene los campos de una línea de /etc/passwd La primera vez que se la llama devuelve la primera entrada; a partir de ahí, devuelve las</Descripción>
<ID>755</ID><Size>2828</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función getservent() lee la siguiente línea del fichero /etc/services y devuelve una estructura servent que contiene en sus campos los campos de la línea Si es necesario, se abre el fichero /etc/se</Descripción>
<ID>756</ID><Size>3059</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función random() emplea un generador no lineal aditivo con retroalimentación de números aleatorios utilizando una tabla predeterminada de 31 enteros largos para devolver números pseudo-aleatorios s</Descripción>
<ID>757</ID><Size>1163</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función getusershell() devuelve la siguiente línea del fichero /etc/shells, abriéndolo si es necesario La línea debería contener la ruta de una shell de usuario válida Si /etc/shells no existe o no</Descripción>
<ID>758</ID><Size>4600</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>utmpname() establece qué nombre tiene el fichero en formato utmp al que van a acceder las otras funciones descritas aquí Si utmpname() no se llama para establecer el nombre de fichero antes de que se </Descripción>
<ID>759</ID><Size>4241</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>Los tres tipos disponibles de estrategias de asignación de búferes son sin búfer, con búfer de bloque, y con búfer de línea Cuando un flujo de salida está sin búfer, la información aparece en el fiche</Descripción>
<ID>760</ID><Size>1578</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función sigsetops(3) permite la manipulación de conjuntos de señales, según la norma POSIX sigemptyset inicia el conjunto de señales dado por conjunto al conjunto vacío, con todas las señales fuera</Descripción>
<ID>761</ID><Size>1578</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función sigsetops(3) permite la manipulación de conjuntos de señales, según la norma POSIX sigemptyset inicia el conjunto de señales dado por conjunto al conjunto vacío, con todas las señales fuera</Descripción>
<ID>762</ID><Size>1578</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función sigsetops(3) permite la manipulación de conjuntos de señales, según la norma POSIX sigemptyset inicia el conjunto de señales dado por conjunto al conjunto vacío, con todas las señales fuera</Descripción>
<ID>763</ID><Size>1578</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función sigsetops(3) permite la manipulación de conjuntos de señales, según la norma POSIX sigemptyset inicia el conjunto de señales dado por conjunto al conjunto vacío, con todas las señales fuera</Descripción>
<ID>764</ID><Size>1647</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función siginterrupt() cambia el comportamiento de reanudación cuando una señal sig interrumpe una llamada al sistema Si el argumento flag es falso (0), entonces las llamadas al sistema se reanudar</Descripción>
<ID>765</ID><Size>1578</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función sigsetops(3) permite la manipulación de conjuntos de señales, según la norma POSIX sigemptyset inicia el conjunto de señales dado por conjunto al conjunto vacío, con todas las señales fuera</Descripción>
<ID>766</ID><Size>1903</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>longjmp() y setjmp() son útiles para tratar con errores e interrupciones encontrados en una subrutina de bajo nivel de un programa longjmp() restaura el entorno salvaguardado por la última llamada a s</Descripción>
<ID>767</ID><Size>1670</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>Las funciones setjmp() y longjmp() son útiles para tratar con errores e interrupciones encontradas en una subrutina de bajo nivel de un programa setjmp() guarda el entorno/contexto de pila en env para</Descripción>
<ID>768</ID><Size>1578</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función sigsetops(3) permite la manipulación de conjuntos de señales, según la norma POSIX sigemptyset inicia el conjunto de señales dado por conjunto al conjunto vacío, con todas las señales fuera</Descripción>
<ID>769</ID><Size>568</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función sin() devuelve el seno de x, en donde x se proporciona en radianes VALOR DEVUELTO La función sin() devuelve un valor entre -1 y 1 CONFORME A SVID 3, POSIX, BSD 4.3, ISO 9899 VEA TAMBIÉN aco</Descripción>
<ID>770</ID><Size>553</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función sinh() devuelve el seno hiperbólico de x, la cual se define matemáticamente como (exp(x) - exp(-x)) / 2 CONFORME A SVID 3, POSIX, BSD 4.3, ISO 9899 VEA TAMBIÉN acosh(3), asinh(3), atanh(3),</Descripción>
<ID>771</ID><Size>1009</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>sleep() hace que el proceso en curso se duerma hasta que hayan transcurrido segundos segundos o hasta que llegue una señal que sea tenida en cuenta VALOR DEVUELTO Cero si el tiempo pedido ha pasado, o</Descripción>
<ID>772</ID><Size>2518</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>snprintf escribe en la cadena de caracteres str, bajo el control de la cadena de caracteres format que especifica cómo se convertirán los siguientes argumentos en la salida Es similar a sprintf(3), sa</Descripción>
<ID>773</ID><Size>16869</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La familia de funciones printf produce una salida de acuerdo a format como se describe abajo Printf y vprintf escriben su salida a stdout, el flujo de salida estándar; fprintf y vfprintf escriben su s</Descripción>
<ID>774</ID><Size>537</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función sqrt() devuelve la raíz cuadrada no negativa de x Falla y pone EDOM en errno si x es negativo ERRORES EDOM x es negativo CONFORME A SVID 3, POSIX, BSD 4.3, ISO 9899 VÉASE TAMBIÉN hypot(3) L</Descripción>
<ID>775</ID><Size>2938</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función rand() devuelve un entero pseudo-aleatorio entre 0 y RAND_MAX La función srand() establece su argumento como la semilla de una nueva serie de enteros seudo-aleatorios que serán devueltos en</Descripción>
<ID>776</ID><Size>4233</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>Estas funciones generan números seudo-aleatorios usando el algoritmo congruente lineal y artimética de enteros de 48 bits Las funciones drand48() y erand48() devuelven valores en coma flotante de dobl</Descripción>
<ID>777</ID><Size>3059</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función random() emplea un generador no lineal aditivo con retroalimentación de números aleatorios utilizando una tabla predeterminada de 31 enteros largos para devolver números pseudo-aleatorios s</Descripción>
<ID>778</ID><Size>12784</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La familia scanf de funciones escudriña la entrada según un formato como se describe más adelante Este formato puede contener especificadores de conversión; los resultados de tales conversiones, si la</Descripción>
<ID>779</ID><Size>4498</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>Una función podría ser llamada con un número de argumentos variable de tipos igualmente variables El archivo de cabecera (include) stdarg.h declara un tipo va_list y define tres macros para moverse a </Descripción>
<ID>780</ID><Size>4035</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>Bajo condiciones normales cualquier programa Unix tiene tres flujos de E/S abiertos cuando arranca: uno para la entrada, otro para la salida y otro para imprimir los diagnósticos o mensajes de error E</Descripción>
<ID>781</ID><Size>4035</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>Bajo condiciones normales cualquier programa Unix tiene tres flujos de E/S abiertos cuando arranca: uno para la entrada, otro para la salida y otro para imprimir los diagnósticos o mensajes de error E</Descripción>
<ID>782</ID><Size>9839</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La biblioteca de E/S estándar proporciona una interface de corriente (stream) utilizando un sistema de buffers (memoria intermedia) simple y eficiente La entrada y la salida se mapean en corrientes lo</Descripción>
<ID>783</ID><Size>4035</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>Bajo condiciones normales cualquier programa Unix tiene tres flujos de E/S abiertos cuando arranca: uno para la entrada, otro para la salida y otro para imprimir los diagnósticos o mensajes de error E</Descripción>
<ID>784</ID><Size>1526</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función stpcpy() copia la cadena apuntada por src (la cual incluye el caracter `\0' ) a la matriz apuntada por dest Las cadenas no deben solaparse, y la cadena destino dest tiene que ser lo suficie</Descripción>
<ID>785</ID><Size>1183</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función strcasecmp() compara las dos cadenas s1 y s2, ignorando mayúsculas y minúsculas Devuelve un entero menor , igual , o mayor que cero si s1 es encontrado, respectivamente, es menor, igual, o </Descripción>
<ID>786</ID><Size>1072</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función strcat() une la cadena src a la cadena dest sobreescribiendo el caracter `\0' al final de dest, y entonces añade un caracter final `\0' Las cadenas no deben solaparse, y la cadena dest debe</Descripción>
<ID>787</ID><Size>1000</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función strchr() devuelve un puntero a la primera ocurrencia del carácter c en la cadena de caracteres s La función strrchr() devuelve un puntero a la última ocurrencia del carácter c en la cadena </Descripción>
<ID>788</ID><Size>1179</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función strcmp() compara las dos cadenas de caracteres s1 y s2 Devuelve un entero menor, igual o mayor que cero si se encuentra que s1 es, respectivamente, menor que, igual a (concordante), o mayor</Descripción>
<ID>789</ID><Size>1314</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función strcoll() compara las dos cadenas de caracteres s1 y s2 Devuelve un entero menor, igual o mayor que cero si se encuentra que s1 es menor, igual o mayor que s2 La comparación se basa en la i</Descripción>
<ID>790</ID><Size>1658</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función strcpy() copia la cadena de caracteres apuntada por orig (incluyendo el carácter terminador '\0') al vector apuntado por dest Las cadenas no deben solaparse, y la de destino, dest, debe ser</Descripción>
<ID>791</ID><Size>1243</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función strspn() calcula la longitud del segmento inicial de s que consta únicamente de caracteres en acepta La función strcspn() calcula la longitud del segmento inicial de s que consta únicamente</Descripción>
<ID>792</ID><Size>939</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función strdup() devuelve un puntero a una nueva cadena de caracteres que es un duplicado de la cadena apuntada por s La memoria para la nueva cadena se obtiene automáticamente con malloc(3), y pue</Descripción>
<ID>793</ID><Size>875</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función strerror() devuelve una cadena de caracteres que describe el código de error pasado en el argumento errnum La cadena sólo puede ser usada hasta la siguiente llamada a strerror() VALOR DEVUE</Descripción>
<ID>794</ID><Size>861</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función strfry() mezcla aleatoriamente los caracteres de una cadena cuya dirección se pasa a la función en string mediante llamadas a rand(3) para intercambiar los caracteres aleatoriamente El resu</Descripción>
<ID>795</ID><Size>9434</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función strftime() formatea el tiempo descompuesto en campos tm según la especificación de formato format y coloca el resultado en el vector de caracteres s de tamaño max Los caracteres normales de</Descripción>
<ID>796</ID><Size>2363</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>Las funciones de manejo de cadenas de caracteres realizan operaciones en cadenas de caracteres acabadas en el carácer de código cero Consulte las páginas individuales del Manual para ver las descripci</Descripción>
<ID>797</ID><Size>619</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función strlen() calcula la longitud de la cadena de caracteres s, sin incluir el carácter terminador `\0' VALOR DEVUELTO La función strlen() devuelve el número de caracteres en s CONFORME A SVID 3</Descripción>
<ID>798</ID><Size>1183</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función strcasecmp() compara las dos cadenas s1 y s2, ignorando mayúsculas y minúsculas Devuelve un entero menor , igual , o mayor que cero si s1 es encontrado, respectivamente, es menor, igual, o </Descripción>
<ID>799</ID><Size>1072</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función strcat() une la cadena src a la cadena dest sobreescribiendo el caracter `\0' al final de dest, y entonces añade un caracter final `\0' Las cadenas no deben solaparse, y la cadena dest debe</Descripción>
<ID>800</ID><Size>1179</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función strcmp() compara las dos cadenas de caracteres s1 y s2 Devuelve un entero menor, igual o mayor que cero si se encuentra que s1 es, respectivamente, menor que, igual a (concordante), o mayor</Descripción>
<ID>801</ID><Size>1658</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función strcpy() copia la cadena de caracteres apuntada por orig (incluyendo el carácter terminador '\0') al vector apuntado por dest Las cadenas no deben solaparse, y la de destino, dest, debe ser</Descripción>
<ID>802</ID><Size>822</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función strpbrk() localiza la primera ocurrencia en la cadena s de cualquier carácter de la cadena accept VALOR DEVUELTO La función strpbrk() devuelve un puntero al carácter de s que coincida con u</Descripción>
<ID>803</ID><Size>5214</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>strptime() es la función complementaria de strftime() y convierte la cadena de caracteres a la que apunte buf a un valor de tiempo, que se guarda en la estructura tm a la que apunte tm, utilizando el </Descripción>
<ID>804</ID><Size>1000</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función strchr() devuelve un puntero a la primera ocurrencia del carácter c en la cadena de caracteres s La función strrchr() devuelve un puntero a la última ocurrencia del carácter c en la cadena </Descripción>
<ID>805</ID><Size>1083</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función strsep() devuelve el siguiente elemento de la cadena pcadena delimitado por delim El elemento termina en un caracter `\0', y pcadena es actualizado para apuntar después del elemento VALOR R</Descripción>
<ID>806</ID><Size>1370</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función strsignal() devuelve una cadena que describe la señal cuyo número corresponde al parámetro sig La cadena sólo puede ser usada hasta la siguiente llamada a strsignal() El vector sys_siglist </Descripción>
<ID>807</ID><Size>1243</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función strspn() calcula la longitud del segmento inicial de s que consta únicamente de caracteres en acepta La función strcspn() calcula la longitud del segmento inicial de s que consta únicamente</Descripción>
<ID>808</ID><Size>1026</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función strstr() encuentra la primera ocurrencia de la subcadena needle en la cadena haystack Los caracteres de terminacion `\0' no se comparan VALOR DEVUELTO La función strstr() devuelve un punter</Descripción>
<ID>809</ID><Size>1940</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>La función strtod() convierte la porción inicial de la cadena a la que apunta nptr a representación double El formato esperado para la cadena es un espacio inicial opcional, comprobado por isspace(3),</Descripción>
<ID>810</ID><Size>1712</Size><Creación>Fri Dec  8 10:21:42 2017</Creación><Descripción>Un `token' es una cadena de caracteres no vacía que no está en la cadena delim, seguida por \0 o por un caracter que está en delim La función strtok() puede usarse para analizar (parse) la cadena s en</Descripción>
<ID>811</ID><Size>2497</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>La función strtol() convierte la cadena de entrada nptr en un valor entero de tipo long de acuerdo a la base dada, que debe estar entre 2 y 36 ambos incluidos o ser el valor especial 0 La cadena debe </Descripción>
<ID>812</ID><Size>2438</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>La función strtoul() convierte la cadena nptr en un valor entero largo sin signo de acuerdo con la base dada, la cual debe estar entre 2 y 36 inclusive, o ser el valor especial 0 La cadena debe comenz</Descripción>
<ID>813</ID><Size>1415</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>La función strxfrm() transforma la cadena de caracteres orig a una forma tal que el resultado de llamar a strcmp() sobre dos cadenas que han sido transformadas mediante strxfrm() es el mismo que el de</Descripción>
<ID>814</ID><Size>769</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>La función swab() copia n bytes desde el vector apuntado por desde hacia el vector apuntado por hacia, cambiando los bytes adyacentes pares y nones Esta función se emplea para intercambiar datos entre</Descripción>
<ID>815</ID><Size>6663</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>sysconf() proporciona una forma de que la aplicación determine ciertos valores para límites del sistema u opciones, en tiempo de ejecución Las macros equivalentes definidas en <unistd.h> sólo pueden d</Descripción>
<ID>816</ID><Size>4457</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>closelog() cierra el descriptor que se esté usando para escribir en el registrador del sistema El empleo de closelog() es opcional openlog() abre, para un programa, una conexión con el registrador del</Descripción>
<ID>817</ID><Size>3693</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>system() ejecuta una orden especificada en mandato llamando a /bin/sh -c mandato, y regresa después de que la orden se haya terminado de ejecutar Durante la ejecucion de la orden, se bloqueará SIGCHLD</Descripción>
<ID>818</ID><Size>490</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>La función tan() devuelve la tangente de x, donde x está en radianes CONFORME A SVID 3, POSIX, BSD 4.3, ISO 9899 VÉASE TAMBIÉN acos(3), asin(3), atan(3), atan2(3), cos(3), sin(3) GNU 12 Marzo 1998 TAN</Descripción>
<ID>819</ID><Size>540</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>La función tanh() devuelve la tangente hiperbólica de x, que se define matemáticamente como sinh(x) / cosh(x) CONFORME A SVID 3, POSIX, BSD 4.3, ISO 9899 VÉASE TAMBIÉN acosh(3), asinh(3), atanh(3), co</Descripción>
<ID>820</ID><Size>14809</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>Las funciones termios describen una interfaz general para las terminales que sirve para controlar los puertos de comunicaciones asícronas Muchas de las funciones que aquí se describen poseen un argume</Descripción>
<ID>821</ID><Size>14809</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>Las funciones termios describen una interfaz general para las terminales que sirve para controlar los puertos de comunicaciones asícronas Muchas de las funciones que aquí se describen poseen un argume</Descripción>
<ID>822</ID><Size>14809</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>Las funciones termios describen una interfaz general para las terminales que sirve para controlar los puertos de comunicaciones asícronas Muchas de las funciones que aquí se describen poseen un argume</Descripción>
<ID>823</ID><Size>14809</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>Las funciones termios describen una interfaz general para las terminales que sirve para controlar los puertos de comunicaciones asícronas Muchas de las funciones que aquí se describen poseen un argume</Descripción>
<ID>824</ID><Size>14809</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>Las funciones termios describen una interfaz general para las terminales que sirve para controlar los puertos de comunicaciones asícronas Muchas de las funciones que aquí se describen poseen un argume</Descripción>
<ID>825</ID><Size>14809</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>Las funciones termios describen una interfaz general para las terminales que sirve para controlar los puertos de comunicaciones asícronas Muchas de las funciones que aquí se describen poseen un argume</Descripción>
<ID>826</ID><Size>14809</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>Las funciones termios describen una interfaz general para las terminales que sirve para controlar los puertos de comunicaciones asícronas Muchas de las funciones que aquí se describen poseen un argume</Descripción>
<ID>827</ID><Size>14809</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>Las funciones termios describen una interfaz general para las terminales que sirve para controlar los puertos de comunicaciones asícronas Muchas de las funciones que aquí se describen poseen un argume</Descripción>
<ID>828</ID><Size>6721</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>tsearch, tfind, twalk y tdelete manejan un árbol binario Son una generalización del algoritmo T de Knuth (6.2.2) El primer campo de cada nodo del árbol es un puntero al correspondiente elemento de dat</Descripción>
<ID>829</ID><Size>784</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>La función telldir() devuelve la posición actual asociada al flujo de directorio dir VALOR DEVUELTO La función telldir() devuelve la posición en curso en el flujo de directorio ó -1 si ocurre un error</Descripción>
<ID>830</ID><Size>2840</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>La función tempnam() devuelve un puntero a una cadena que es un nombre válido de fichero tal que no existe un fichero con este nombre cuando tempnam() lo comprueba El sufijo del nombre de fichero de l</Descripción>
<ID>831</ID><Size>14809</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>Las funciones termios describen una interfaz general para las terminales que sirve para controlar los puertos de comunicaciones asícronas Muchas de las funciones que aquí se describen poseen un argume</Descripción>
<ID>832</ID><Size>6721</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>tsearch, tfind, twalk y tdelete manejan un árbol binario Son una generalización del algoritmo T de Knuth (6.2.2) El primer campo de cada nodo del árbol es un puntero al correspondiente elemento de dat</Descripción>
<ID>833</ID><Size>1415</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>La función tmpfile() genera un nombre único de fichero temporal usando el prefijo de trayectoria P_tmpdir definido en <stdio.h> El fichero temporal se abre entonces en modo de lectura/escritura binari</Descripción>
<ID>834</ID><Size>2024</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>La función tmpnam() devuelve un puntero a una cadena que es un nombre válido de fichero tal que no existe un fichero con ese nombre en ningún instante por lo que los programadores ingénuos pueden pens</Descripción>
<ID>835</ID><Size>752</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>toascii() convierte c a un unsigned char de 7 bits que constituye un carácter ASCII, borrando los bits altos VALOR DEVUELTO El valor devuelte es el carácter convertido CONFORME A SVID, BSD FALLOS Much</Descripción>
<ID>836</ID><Size>1184</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>toupper() convierte la letra c a mayúsculas, si es posible tolower() convierte la letra c a minúsculas, si es posible VALOR DEVUELTO El valor devuelto es la letra "convertida", o c si no se pudo reali</Descripción>
<ID>837</ID><Size>1184</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>toupper() convierte la letra c a mayúsculas, si es posible tolower() convierte la letra c a minúsculas, si es posible VALOR DEVUELTO El valor devuelto es la letra "convertida", o c si no se pudo reali</Descripción>
<ID>838</ID><Size>6721</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>tsearch, tfind, twalk y tdelete manejan un árbol binario Son una generalización del algoritmo T de Knuth (6.2.2) El primer campo de cada nodo del árbol es un puntero al correspondiente elemento de dat</Descripción>
<ID>839</ID><Size>589</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>Devuelve un puntero al nombre del camino del terminal que se abre con el descriptor de fichero desc, o NULL si hay algún error (p.e.: si desc no está conectado a un terminal) CONFORME A POSIX.1 VÉASE </Descripción>
<ID>840</ID><Size>6721</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>tsearch, tfind, twalk y tdelete manejan un árbol binario Son una generalización del algoritmo T de Knuth (6.2.2) El primer campo de cada nodo del árbol es un puntero al correspondiente elemento de dat</Descripción>
<ID>841</ID><Size>4418</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>La función tzset() inicializa la variable tzname a partir de la variable de entorno TZ Esta función es invocada automáticamente por otras funciones conversoras de tiempo que dependen de la zona horari</Descripción>
<ID>842</ID><Size>1619</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>Atención: Esta rutina está obsoleta glibc no proporcionará el fichero de cabecera En lugar de ulimit debe usarse getrlimit(2), setrlimit(2) y sysconf(3) Para la orden del shell ulimit, vea bash(1) La </Descripción>
<ID>843</ID><Size>3926</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>Esta página man cita aquellas funciones de biblioteca que, si bien están implementadas en las bibliotecas estándar, no están todavía documentadas en las páginas man SOLICITUDES Si tienes información s</Descripción>
<ID>844</ID><Size>3426</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>fgetc() lee el siguiente carácter de flujo y lo devuelve como un unsigned char modelado a un int, o EOF al llegar al final del flujo o en caso de error getc() es equivalente a fgetc() excepto en el he</Descripción>
<ID>845</ID><Size>1048</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>La función setenv() añade la variable nombre al entorno o ambiente con el valor valor, si nombre no existe ya Si nombre sí existe ya en el ambiente, entonces su valor se cambia a valor si sobrescribir</Descripción>
<ID>846</ID><Size>1055</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>updwtmp() añade la estructura utmp ut al fichero wtmp logwtmp() crea una estructura utmp utilizando línea, nombre, host, instante de tiempo actual e identificador del proceso actual A continuación, ll</Descripción>
<ID>847</ID><Size>715</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>La función usleep() suspende la ejecución del proceso llamante durante usec microsegundos La pausa puede prolongarse ligeramente por cualquier actividad en el sistema o por el tiempo gastado procesand</Descripción>
<ID>848</ID><Size>4600</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>utmpname() establece qué nombre tiene el fichero en formato utmp al que van a acceder las otras funciones descritas aquí Si utmpname() no se llama para establecer el nombre de fichero antes de que se </Descripción>
<ID>849</ID><Size>4498</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>Una función podría ser llamada con un número de argumentos variable de tipos igualmente variables El archivo de cabecera (include) stdarg.h declara un tipo va_list y define tres macros para moverse a </Descripción>
<ID>850</ID><Size>4498</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>Una función podría ser llamada con un número de argumentos variable de tipos igualmente variables El archivo de cabecera (include) stdarg.h declara un tipo va_list y define tres macros para moverse a </Descripción>
<ID>851</ID><Size>4498</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>Una función podría ser llamada con un número de argumentos variable de tipos igualmente variables El archivo de cabecera (include) stdarg.h declara un tipo va_list y define tres macros para moverse a </Descripción>
<ID>852</ID><Size>16869</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>La familia de funciones printf produce una salida de acuerdo a format como se describe abajo Printf y vprintf escriben su salida a stdout, el flujo de salida estándar; fprintf y vfprintf escriben su s</Descripción>
<ID>853</ID><Size>12784</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>La familia scanf de funciones escudriña la entrada según un formato como se describe más adelante Este formato puede contener especificadores de conversión; los resultados de tales conversiones, si la</Descripción>
<ID>854</ID><Size>16869</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>La familia de funciones printf produce una salida de acuerdo a format como se describe abajo Printf y vprintf escriben su salida a stdout, el flujo de salida estándar; fprintf y vfprintf escriben su s</Descripción>
<ID>855</ID><Size>12784</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>La familia scanf de funciones escudriña la entrada según un formato como se describe más adelante Este formato puede contener especificadores de conversión; los resultados de tales conversiones, si la</Descripción>
<ID>856</ID><Size>2518</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>snprintf escribe en la cadena de caracteres str, bajo el control de la cadena de caracteres format que especifica cómo se convertirán los siguientes argumentos en la salida Es similar a sprintf(3), sa</Descripción>
<ID>857</ID><Size>16869</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>La familia de funciones printf produce una salida de acuerdo a format como se describe abajo Printf y vprintf escriben su salida a stdout, el flujo de salida estándar; fprintf y vfprintf escriben su s</Descripción>
<ID>858</ID><Size>12784</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>La familia scanf de funciones escudriña la entrada según un formato como se describe más adelante Este formato puede contener especificadores de conversión; los resultados de tales conversiones, si la</Descripción>
<ID>859</ID><Size>864</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>La función wcstombs() convierte una secuencia de caracteres anchos desde el vector pwcs a una secuencia de caracteres multibyte y guarda hasta n bytes de caracteres multibyte en el vector s VALOR DEVU</Descripción>
<ID>860</ID><Size>764</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>La función wctomb() convierte un carácter ancho wchar en un carácter multibyte y, si s no es NULL, guarda la representación del carácter multibyte en s VALOR DEVUELTO wctomb() devuelve el número de by</Descripción>
<ID>861</ID><Size>2602</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>La función readv() lee num bloques del fichero asociado con el descriptor de fichero descfic en los múltiples búferes descritos por vector La función writev() escribe como mucho num bloques descritos </Descripción>
<ID>862</ID><Size>1276</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>Las funciones j0() y j1() devuelven las funciones de Bessel de x de primera clase de órdenes 0 y 1, respectivamente La función jn() devuelve la función de Bessel de x de primera clase de orden n Las f</Descripción>
<ID>863</ID><Size>1276</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>Las funciones j0() y j1() devuelven las funciones de Bessel de x de primera clase de órdenes 0 y 1, respectivamente La función jn() devuelve la función de Bessel de x de primera clase de orden n Las f</Descripción>
<ID>864</ID><Size>1276</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>Las funciones j0() y j1() devuelven las funciones de Bessel de x de primera clase de órdenes 0 y 1, respectivamente La función jn() devuelve la función de Bessel de x de primera clase de orden n Las f</Descripción>
<ID>865</ID><Size>1022</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>__setfpucw transfiere control_word a los registros de la fpu (floating point unit, unidad de coma flotante) en la arquitectura i386 Esto se puede utilizar para controlar la precisión de punto flotante</Descripción>
<ID>866</ID><Size>12816</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>Linux es un sistema operativo internacional Varias de sus utilidades y controladores de dispositivos (incluyendo el de la consola) admiten conjuntos de caracteres multilingües incluyendo letras del al</Descripción>
<ID>867</ID><Size>2865</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>Un sistema Linux tiene hasta 63 consolas virtuales (dispositivos de carácter de número mayor 4 y menor de 1 a 63), denominadas habitualmente /dev/ttyn donde 1 <= n <= 63 La consola actual se designa t</Descripción>
<ID>868</ID><Size>25587</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>La consola de Linux implementa un vasto subconjunto de los controles de terminal de la VT102 y del estándar ECMA-48/ISO 6429/ANSI X3.64, más ciertas secuencias de modo privadas para cambiar la paleta </Descripción>
<ID>869</ID><Size>24659</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>ATENCIÓN: Si Ud usa la siguiente información, es bajo su reponsabilidad Allá Ud ATENCIÓN: Estas llamadas a ioctl son internas a Linux y no documentadas, sujetas a cambios sin previo aviso Use funcione</Descripción>
<ID>870</ID><Size>8980</Size><Creación>Fri Dec  8 10:21:43 2017</Creación><Descripción>Los ficheros especiales fd acceden a las unidades de disquete en modo crudo Las siguientes llamadas ioctl(2) están soportadas por dispositivos fd: FDCLRPRM borra la información del medio de una unidad</Descripción>
<ID>871</ID><Size>931</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>El fichero /dev/full tiene como número mayor de dispositivo el 1, y como número menor de dispositivo el 7 Las escrituras en el dispositivo /dev/full fallarán con un error ENOSPC Las lecturas desde el </Descripción>
<ID>872</ID><Size>2287</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>hd* son los dispositivos de bloque usados para acceder a los discos duros MFM/IDE en modo crudo (raw mode) El disco duro maestro de la controladora primaria IDE (dispositivo mayor número 3) es hda el </Descripción>
<ID>873</ID><Size>14978</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>El fichero especial /dev/initrd es un dispositivo de bloques de sólo lectura El dispositivo /dev/initrd es un disco RAM que es inicializado (es decir, cargado) por el gestor de arranque antes de carga</Descripción>
<ID>874</ID><Size>574</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>Este capítulo describe los archivos especiales FICHEROS /dev/* -- archivos de dispositivo AUTORES Mire la cabecera de cada página del manual para saber el/los autor/es y las condiciones de derechos de</Descripción>
<ID>875</ID><Size>1558</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>mem es un fichero de dispositivo de caracteres que representa a la memoria principal del ordenador Se puede utilizar, por ejemplo, para examinar (e incluso parchear) el sistema En mem, las direcciones</Descripción>
<ID>876</ID><Size>5630</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>Se aceptan las siguientes llamadas ioctl(2): int ioctl(int fd, LPTIME, int arg) arg es la cantidad de tiempo que el controlador dormirá antes de re-comprobar la impresora, cuando el tampón de la impre</Descripción>
<ID>877</ID><Size>9086</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>Esta página del Manual documenta el formato del fichero mágico que emplea la orden file(1), versión 3.26 La orden file identifica el tipo de un fichero utilizando, entre otras pruebas, una que mira si</Descripción>
<ID>878</ID><Size>1558</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>mem es un fichero de dispositivo de caracteres que representa a la memoria principal del ordenador Se puede utilizar, por ejemplo, para examinar (e incluso parchear) el sistema En mem, las direcciones</Descripción>
<ID>879</ID><Size>5888</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>Introducción El diagrama de conexión de un conector de 9 pines normal como el usado por un ratón serie es: pin nombre usado para 2 RX Data 3 TX -12 V, Imax = 10 mA 4 DTR +12 V, Imax = 10 mA 7 RTS +12 </Descripción>
<ID>880</ID><Size>951</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>Los datos escritos en los ficheros especiales null o zero se desechan La lectura del fichero especial null siempre devuelve "fin de fichero (EOF)", mientras que la lectura del fichero zero siempre dev</Descripción>
<ID>881</ID><Size>1558</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>mem es un fichero de dispositivo de caracteres que representa a la memoria principal del ordenador Se puede utilizar, por ejemplo, para examinar (e incluso parchear) el sistema En mem, las direcciones</Descripción>
<ID>882</ID><Size>524</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>ram es el dispositivo de bloque usado para acceder al disco ram en modo crudo (raw mode) Normalmente se crea con: mknod -m 660 /dev/ram b 1 1 chown root:disk /dev/ram FICHEROS /dev/ram VÉASE TAMBIÉN m</Descripción>
<ID>883</ID><Size>4639</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>Los ficheros especiales de caracteres /dev/random y /dev/urandom (presente desde la versión 1.3.30 de Linux) proporcionan una interfaz con el generador de números aleatorios del núcleo El ficheros /de</Descripción>
<ID>884</ID><Size>3589</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>Las siguientes ioctl() están disponibles: HDIO_GETGEO Devuelve los parámetros del disco de la BIOS, en la siguiente estructura: struct hd_geometry { unsigned char heads; /*Número de cabezas*/ unsigned</Descripción>
<ID>885</ID><Size>39750</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>El manejador (driver) st proporciona la interfaz para una variedad de dispositivos de cinta magnética SCSI Actualmente, toma el control de todos los dispositivos detectados de tipo "acceso secuencial"</Descripción>
<ID>886</ID><Size>1557</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>El fichero /dev/tty es un dispositivo de carácter con el número mayor 5 y número menor 0, creado normalmente con el modo 0666 y propietario root.tty Es un sinónimo del terminal en control de un proces</Descripción>
<ID>887</ID><Size>750</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>ttyS[0-3] son los dispositivos de carácter para las líneas serie de terminales Normalmente se crean con: mknod -m 660 /dev/ttyS0 c 4 64 # dir base 0x03f8 mknod -m 660 /dev/ttyS1 c 4 65 # dir base 0x02</Descripción>
<ID>888</ID><Size>3211</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>/dev/vcs0 es un dispositivo de carácter con número mayor 7 y número menor 0, creado normalmente con modo 0644 y propietario root.tty Designa la memoria del terminal de consola virtual visualizado en e</Descripción>
<ID>889</ID><Size>3211</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>/dev/vcs0 es un dispositivo de carácter con número mayor 7 y número menor 0, creado normalmente con modo 0644 y propietario root.tty Designa la memoria del terminal de consola virtual visualizado en e</Descripción>
<ID>890</ID><Size>4930</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>wavelan es el controlador de dispositivo de bajo nivel para el adaptador Ethernet inalámbrico WaveLAN ISA de NCR / AT&T / Lucent y RoamAbout DS de Digital (DEC) Este controlador está disponible como m</Descripción>
<ID>891</ID><Size>951</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>Los datos escritos en los ficheros especiales null o zero se desechan La lectura del fichero especial null siempre devuelve "fin de fichero (EOF)", mientras que la lectura del fichero zero siempre dev</Descripción>
<ID>892</ID><Size>745</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>El núcleo mantiene una estructura de información contable para todos los procesos Si un proceso finaliza, y la contabilidad está activada, el núcleo llama a la función acct(2) para preparar, y luego a</Descripción>
<ID>893</ID><Size>932</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>Los ficheros /etc/at.access y /etc/at.deny determinan qué usuarios pueden enviar comandos para su ejecución posterior mediante at(1) o batch(1) El formato de los ficheros consiste en una lista de nomb</Descripción>
<ID>894</ID><Size>3575</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>Una descripción de conjunto de caracteres (mapcar) define un conjunto de caracteres disponibles y sus codificaciones Todos los conjuntos de caracteres admitidos deberían tener como subconjunto el conj</Descripción>
<ID>895</ID><Size>4988</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>La variable environ apunta a un vector de cadenas llamado `el entorno' (Esta variable se debe declarar en el programa de usuario, aunque se declara en el fichero cabecera unistd.h en el caso de que lo</Descripción>
<ID>896</ID><Size>1084</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>/etc/ethers contiene direcciones Ethernet de 48 bits y sus números IP correspondientes, una línea para cada número IP: Ethernet-address IP-number Los dos números se separan por un número cualquiera de</Descripción>
<ID>897</ID><Size>9314</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>El fichero /etc/exports sirve como la lista de control de acceso para sistemas de ficheros que pueden ser exportados a clientes NFS Lo utilizan el duende de montaje mountd(8) y el duende servidor de f</Descripción>
<ID>898</ID><Size>6116</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>En el fichero /proc/filesystems se pueden encontrar los nombres de los sistemas de ficheros que el núcleo reconoce actualmente (En caso de necesitar un sistema de ficheros no reconocido actualmente, i</Descripción>
<ID>899</ID><Size>5041</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>El fichero fstab contiene información que describe los diversos sistemas de ficheros Los programas sólo pueden leer fstab ; el administrador del sistema es responsable de la creación y mantenimiento d</Descripción>
<ID>900</ID><Size>2497</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>El archivo /etc/suck/get-news.conf contiene los parámetros por defecto que empleará get-news(1) Los parámetros se especifican según el formato: nombre:[espacios opcionales]valor donde por nombre se en</Descripción>
<ID>901</ID><Size>1011</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>/etc/group es un fichero ASCII el cuál define los grupos a los cuáles pertenecen los usuarios del sistema Hay una entrada por línea, y cada línea tiene el siguiente formato: nombre_grupo:contraseña:GI</Descripción>
<ID>902</ID><Size>3965</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>El fichero /etc/host.conf contiene información de configuración específica de la biblioteca del resolvedor de nombres de Internet Debería contener una palabra clave de configuración por cada línea, se</Descripción>
<ID>903</ID><Size>1486</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>Cuando el guión de entorno /etc/initscript existe, init lo usará para ejecutar comandos para inittab Este guión puede ser usado para cosas como, por ejemplo, colocar los valores por defecto ulimit y u</Descripción>
<ID>904</ID><Size>8434</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>El fichero inittab describe qué procesos se inician en la carga y durante la operación normal (por ejemplo, /etc/init.d/boot, /etc/init.d/rc, gettys ) Init(8) distingue múltiples niveles de ejecución,</Descripción>
<ID>905</ID><Size>612</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>Este capítulo describe varios formatos de ficheros, protocolos, y las estructuras de datos usadas por los distintos programas AUTORES Mire la cabecera de cada página del manual para saber el/los autor</Descripción>
<ID>906</ID><Size>8366</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>Esta página del manual hace referencia a la implementación en Linux de los mecanismos de comunicación entre procesos del System V (IPC, InterProcess Communication): colas de mensajes, conjuntos de sem</Descripción>
<ID>907</ID><Size>623</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>--NO POSEE DESCRIPCIÓN--</Descripción>
<ID>908</ID><Size>1208</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>El fichero /etc/issue.net es un fichero de texto que contiene un mensaje o una identificación del sistema que será impreso justo antes de que aparezca el indicador de comandos (prompt) de una sesión d</Descripción>
<ID>909</ID><Size>21158</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>Este fichero lo utiliza lilo, el instalador del cargador de arranque (véase lilo(8)) Por omisión, este fichero es: /etc/lilo.conf Lo siguiente es un ejemplo de este fichero: boot = /dev/hda delay = 40</Descripción>
<ID>910</ID><Size>14025</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>Los ficheros de definición de localización o locale contienen toda la información que la orden localedef(1) necesita para convertirlos a la base de datos binaria de localización Los ficheros de defini</Descripción>
<ID>911</ID><Size>6092</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>Esta página de manual documenta el formato de las bases de datos de nombres de fichero para la versión GNU de locate La base de datos de nombres de fichero contiene listas de los ficheros que estaban </Descripción>
<ID>912</ID><Size>1216</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>Este ficheiro es leido por man(1) y contiene: (a) información de como construir el camino de búsqueda de las páginas (manpath); (b) nombres completos de vários programas como nroff, eqn, tbl, etc usad</Descripción>
<ID>913</ID><Size>744</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>login(1) muestra el contenido del fichero /etc/motd después de un inicio de sesión (login) con éxito pero justo antes de que ejecute el intérprete de comandos de entrada al sistema "motd" significa "m</Descripción>
<ID>914</ID><Size>1778</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>Este programa, utilidad o función no tiene una página útil en el manual Por favor no se dirija a nosotros indicandonoslo, ya que lo tenemos clasificado como error; cuando haya una página disponible, s</Descripción>
<ID>915</ID><Size>11959</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>El fichero fstab contiene información acerca de qué sistemas de ficheros montar, dónde montarlos y con qué opciones Para montajes NFS, contiene el nombre del servidor y el directorio exportado en ese </Descripción>
<ID>916</ID><Size>543</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>Si el fichero /etc/nologin existe, login(1) sólo permitirá acceder al usuario root A cualquier otro usuario se le mostrará el contenido de este fichero y sus conexiones serán rechazadas FICHEROS /etc/</Descripción>
<ID>917</ID><Size>8811</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>Varias funciones de la librería C necesitan ser configuradas para trabajar correctamente en el entorno local Tradicionalmente, esto se hacía utilizando ficheros (e.g., `/etc/passwd'), pero otros servi</Descripción>
<ID>918</ID><Size>4802</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>Passwd es un fichero de texto que contiene una lista de las cuentas del sistema, proporcionando para cada cuenta cierta información útil como el identificador (ID) de usuario, el ID de grupo, el direc</Descripción>
<ID>919</ID><Size>36306</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>/proc es un pseudo-sistema de ficheros que se usa como interfaz para las estructuras de datos del kernel en lugar de leer e interpretar /dev/kmem La mayor parte de este sistema de ficheros es de sólo </Descripción>
<ID>920</ID><Size>22272</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>Para un descripción del formato del fichero de recursos véase procmailrc(5) La técnica de puntuación de peso se describe en detalle en la página de manual de procmailsc(5) Esta página de manual muestr</Descripción>
<ID>921</ID><Size>37720</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>Para un comienzo rápido, véase NOTAS al final de la página de manual de procmail(1) El fichero de recursos puede contener una mezcla de asignaciones de variables de entorno (algunas de las cuales pued</Descripción>
<ID>922</ID><Size>9950</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>Además de las condiciones tradicionales verdadero o falso que puede especificar en una receta, puede usar técnicas de puntuación de peso para decidir si una cierta receta concuerda o no Cuando se usa </Descripción>
<ID>923</ID><Size>1833</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>Éste es un fichero ASCII plano que describe los distintos protocolos DARPA para Internet que están disponibles en el subsistema TCP/IP Se debería consultar este fichero en vez de usar los números de l</Descripción>
<ID>924</ID><Size>4396</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>/etc/raidtab es el fichero de configuración por defecto para las herramientas RAID (raidadd y compañía) Define cómo se configuran los dispositivos RAID del sistema FORMATO /etc/raidtab tiene varias se</Descripción>
<ID>925</ID><Size>6542</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>El resolvedor es un conjunto de rutinas en la biblioteca de C que proporcionan acceso al Sistema de Nombres de Dominio de Internet El fichero de configuración del resolvedor contiene información que e</Descripción>
<ID>926</ID><Size>6542</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>El resolvedor es un conjunto de rutinas en la biblioteca de C que proporcionan acceso al Sistema de Nombres de Dominio de Internet El fichero de configuración del resolvedor contiene información que e</Descripción>
<ID>927</ID><Size>549</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>/etc/securetty lo utiliza el programa login(1); el fichero contiene los nombres de dispositivo de líneas de tty (sin el prefijo /dev/) que root puede usar para entrar en el sistema FICHEROS /etc/secur</Descripción>
<ID>928</ID><Size>6685</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>services es un fichero ASCII que proporciona una correspondencia entre nombres textuales cómodos para los servicios de internet y sus correspondientes números de puerto y tipos de protocolo subyacente</Descripción>
<ID>929</ID><Size>756</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>/etc/shells es un fichero de texto que contiene el nombre de ruta completo para intérpretes de órdenes que puedan utilizarse al entrar en el sistema Este fichero es consultado por chsh(1) y está dispo</Descripción>
<ID>930</ID><Size>20592</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>/etc/termcap es un fichero ASCII que contiene las características de multitud de tipos de terminal Los programas pueden leer termcap para encontrar los códigos de escape particulares que se necesitan </Descripción>
<ID>931</ID><Size>1353</Size><Creación>Fri Dec  8 10:21:44 2017</Creación><Descripción>El fichero de texto /etc/ttytype asocia los nombres de tipo de terminal según termcap/terminfo a las líneas de tty Cada línea consiste en un tipo de terminal, espacio en blanco, y un nombre de tty (un</Descripción>
<ID>932</ID><Size>4986</Size><Creación>Fri Dec  8 10:21:45 2017</Creación><Descripción>Los ficheros de información de huso horario usados por tzset(3) comienzan con la secuencia de caracteres mágicos "TZif" para identificarlos como ficheros de información de huso horario, seguidos por 1</Descripción>
<ID>933</ID><Size>10056</Size><Creación>Fri Dec  8 10:21:45 2017</Creación><Descripción>El fichero utmp nos permite obtener información de quiénes están usando el sistema actualmente Puede haber más usuarios usando el sistema en el momento actual ya que no todos los programas usan utmp c</Descripción>
<ID>934</ID><Size>10056</Size><Creación>Fri Dec  8 10:21:45 2017</Creación><Descripción>El fichero utmp nos permite obtener información de quiénes están usando el sistema actualmente Puede haber más usuarios usando el sistema en el momento actual ya que no todos los programas usan utmp c</Descripción>
<ID>935</ID><Size>1469</Size><Creación>Fri Dec  8 10:21:45 2017</Creación><Descripción>Banner imprime un título grande y de gran calidad en la salida estandar Si se omite el mensaje, pregunta por él, y lee una línea de su entrada estandar Si -w se incluye, la salida se achata desde una </Descripción>
<ID>936</ID><Size>560</Size><Creación>Fri Dec  8 10:21:45 2017</Creación><Descripción>Este capítulo describe todos los juegos y pequeños entretenimientos disponibles en el sistema AUTORES Los autores y derechos de autor aparecen en el encabezamiento de cada una de las páginas del manua</Descripción>
<ID>937</ID><Size>11949</Size><Creación>Fri Dec  8 10:21:45 2017</Creación><Descripción>Este módulo de protocolo del núcleo implementa el protocolo de resolución de direcciones (Address Resolution Protocol, ARP) definido en RFC 826 Se usa para convertir direcciones hardware de la Capa 2 </Descripción>
<ID>938</ID><Size>5406</Size><Creación>Fri Dec  8 10:21:45 2017</Creación><Descripción>ASCII significa American Standard Code for Information Interchange, Código Estándar Americano para Intercambio de Información Es un código de 7 bits Muchos códigos de 8 bits (como el ISO 8859-1, el co</Descripción>
<ID>939</ID><Size>56188</Size><Creación>Fri Dec  8 10:21:45 2017</Creación><Descripción>El núcleo Linux acepta ciertas `opciones de la línea de orden' o `parámetros de arranque' cuando se carga En general esto sirve para suministrar al núcleo información sobre parámetros del equipo que e</Descripción>
<ID>940</ID><Size>7890</Size><Creación>Fri Dec  8 10:21:45 2017</Creación><Descripción>Linux implementa el protocolo Appletalk descrito en Inside Appletalk Únicamente la capa DDP y el AARP se encuentran dentro del núcleo Están diseñados para ser usados mediante las librerías netatalk de</Descripción>
<ID>941</ID><Size>8522</Size><Creación>Fri Dec  8 10:21:45 2017</Creación><Descripción>Hace mucho tiempo, en Unix V6, había un programa en /etc/glob que expandía patrones con comodines Poco después este programa se convirtió en una orden incorporada en el shell Hogaño existe también una</Descripción>
<ID>942</ID><Size>13511</Size><Creación>Fri Dec  8 10:21:45 2017</Creación><Descripción>Un sistema Linux típico tiene, entre otros, los siguientes directorios: / Este es el directorio raiz Aquí comienza todo el árbol de directorios /bin Este directorio contiene programas ejecutables que </Descripción>
<ID>943</ID><Size>4604</Size><Creación>Fri Dec  8 10:21:45 2017</Creación><Descripción>Este módulo de protocolo del núcleo implementa el Protocolo de Mensajes de Control de Internet (Internet Control Message Protocol, ICMP) definido en el documento RFC792 Se utiliza para indicar condici</Descripción>
<ID>944</ID><Size>719</Size><Creación>Fri Dec  8 10:21:45 2017</Creación><Descripción>Esta sección describe diversos tópicos tales como los paquetes de macros para nroff, tablas, ficheros de cabecera en C, la jerarquía de ficheros, conceptos generales, y otras cosas que no encajan en n</Descripción>
<ID>945</ID><Size>31800</Size><Creación>Fri Dec  8 10:21:45 2017</Creación><Descripción>Linux implementa el Protocolo de Internet (Internet Protocol, IP), version 4, descrito en RFC791 y RFC1122 ip contiene una implementación de multidestino del Nivel 2 según el RFC1112 También contiene </Descripción>
<ID>946</ID><Size>7657</Size><Creación>Fri Dec  8 10:21:45 2017</Creación><Descripción>El estándar ISO 8859 incluye varias extensiones de 8 bits al conjunto de caracteres ASCII (también conocido como ISO 646-IRV) De especial importancia es ISO 8859-1, el "Alfabeto Latino Nº 1", el cual </Descripción>
<ID>947</ID><Size>7657</Size><Creación>Fri Dec  8 10:21:45 2017</Creación><Descripción>El estándar ISO 8859 incluye varias extensiones de 8 bits al conjunto de caracteres ASCII (también conocido como ISO 646-IRV) De especial importancia es ISO 8859-1, el "Alfabeto Latino Nº 1", el cual </Descripción>
<ID>948</ID><Size>6960</Size><Creación>Fri Dec  8 10:21:45 2017</Creación><Descripción>Una localidad (locale) es un conjunto de reglas culturales e idiomáticas que abarcan aspectos tales como el idioma usado para mensajes, diferentes juegos de caracteres, convenios lexicográficos, etc U</Descripción>
<ID>949</ID><Size>5051</Size><Creación>Fri Dec  8 10:21:45 2017</Creación><Descripción>Esta página del manual facilita una breve introducción al uso de direcciones de correo electrónico en SMTP, como las usadas en Internet Las direcciones siguen en general el siguiente formato: usuario@</Descripción>
<ID>950</ID><Size>8549</Size><Creación>Fri Dec  8 10:21:45 2017</Creación><Descripción>Esta página del manual describe el paquete de macros groff tmac.an El programador debe usar este paquete de macros cuando escriba o porte páginas del manual para Linux Al ser bastante compatible con o</Descripción>
<ID>951</ID><Size>8732</Size><Creación>Fri Dec  8 10:21:45 2017</Creación><Descripción>Esta página de manual describe la interfaz de conectores que se usa para configurar los dispositivos de red Linux soporta algunas ioctls estándares para configurar los dispositivos de red Se pueden us</Descripción>
<ID>952</ID><Size>10655</Size><Creación>Fri Dec  8 10:21:45 2017</Creación><Descripción>Netlink se utiliza para transferir información entre los módulos del núcleo y los procesos del espacio de usuario Consiste en una interfaz basada en conectores estándares para los procesos de usuario </Descripción>
<ID>953</ID><Size>10747</Size><Creación>Fri Dec  8 10:21:45 2017</Creación><Descripción>Los conectores de paquetes (packet sockets) se usan para recibir o enviar paquetes directos (raw) en el nivel del manejador de dispositivo (Nivel 2 de OSI) Permiten al usuario implementar módulos de p</Descripción>
<ID>954</ID><Size>9118</Size><Creación>Fri Dec  8 10:21:45 2017</Creación><Descripción>Los conectores directos permiten implementar nuevos protocolos IPv4 en el espacio de usuario Un conector directo recibe o envía el datagrama crudo sin incluir cabeceras del nivel de enlace La capa IPv</Descripción>
<ID>955</ID><Size>12916</Size><Creación>Fri Dec  8 10:21:45 2017</Creación><Descripción>Las expresiones regulares (``ER''s), tal y como se definen en POSIX 1003.2, tienen dos formas: ERs modernas (tal y como egrep; llama a estas ERs ``extendidas'' de 1003.2) y ERs obsoletas (las que usa </Descripción>
<ID>956</ID><Size>5931</Size><Creación>Fri Dec  8 10:21:45 2017</Creación><Descripción>Una expresión regular es un patrón que describe un conjunto de cadenas de caracteres Las expresiones regulares se construyen de forma análoga a las aritméticas, empleándose varios operadores para comb</Descripción>
<ID>957</ID><Size>26505</Size><Creación>Fri Dec  8 10:21:45 2017</Creación><Descripción>Rtnetlink permite leer y alterar las tablas de enrutamiento del núcleo Se usa dentro del núcleo para comunicar entre sí varios subsistemas (aunque este uso no se documenta aquí) y para la comunicación</Descripción>
<ID>958</ID><Size>4801</Size><Creación>Fri Dec  8 10:21:45 2017</Creación><Descripción>Linux permite el uso de las señales dadas a continuación Los números de varias de las señales dependen de la arquitectura del sistema Primero, las señales descritas en POSIX.1 Señal Valor Acción Comen</Descripción>
<ID>959</ID><Size>19059</Size><Creación>Fri Dec  8 10:21:45 2017</Creación><Descripción>Esta página de manual describe la interfaz de usuario de la capa de conectores de red de Linux Los conectores compatibles con BSD son la interfaz uniforme entre el proceso de usuario y las pilas de pr</Descripción>
<ID>960</ID><Size>12402</Size><Creación>Fri Dec  8 10:21:45 2017</Creación><Descripción>Es costumbre indicar el contenido de un fichero mediante el sufijo del fichero, que consiste en un punto seguido de una o más letras Muchas utilidades estándar tales como compiladores lo usan para rec</Descripción>
<ID>961</ID><Size>13193</Size><Creación>Fri Dec  8 10:21:45 2017</Creación><Descripción>Ésta es una implementación del protocolo TCP definido en RFC793, RFC1122 y RFC2001 con las extensiones NewReno y SACK Proporciona una conexión bidireccional, fiable y orientada a conexión entre dos co</Descripción>
<ID>962</ID><Size>4672</Size><Creación>Fri Dec  8 10:21:45 2017</Creación><Descripción>Ésta es una implementación del protocolo UDP (User Datagram Protocol) descrito en RFC768 Implementa un servicio de paquetes de datagramas no fiable y sin conexión Los paquetes pueden ser reordenados o</Descripción>
<ID>963</ID><Size>1778</Size><Creación>Fri Dec  8 10:21:45 2017</Creación><Descripción>Este programa, utilidad o función no tiene una página útil en el manual Por favor no se dirija a nosotros indicandonoslo, ya que lo tenemos clasificado como error; cuando haya una página disponible, s</Descripción>
<ID>964</ID><Size>8695</Size><Creación>Fri Dec  8 10:21:46 2017</Creación><Descripción>El estándar internacional ISO 10646 define el conjunto de caracteres UCS (Universal Character Set - Conjunto de Caracteres Universal) UCS contiene todos los caracteres de todos los demás estándares de</Descripción>
<ID>965</ID><Size>9485</Size><Creación>Fri Dec  8 10:21:46 2017</Creación><Descripción>La familia de conectores PF_UNIX (también conocida como PF_LOCAL o PF_FILE) se usa para comunicar procesos en la misma máquina de manera eficiente Los conectores Unix pueden ser o bien anónimos (cread</Descripción>
<ID>966</ID><Size>4821</Size><Creación>Fri Dec  8 10:21:46 2017</Creación><Descripción>El conjunto de caracteres Unicode ocupa un espacio de códigos de 16 bits La codificación Unicode más obvia (conocida como UCS-2) consiste en una secuencia de palabras de 16 bits Tales cadenas pueden c</Descripción>
<ID>967</ID><Size>4860</Size><Creación>Fri Dec  8 10:21:46 2017</Creación><Descripción>Los conectores (sockets) X25 proporcionan una interfaz al protocolo de la capa de paquetes X.25 Éstos permiten a las aplicaciones comunicarse a través de una red pública de datos X.25 según establece </Descripción>
<ID>968</ID><Size>12635</Size><Creación>Fri Dec  8 10:21:46 2017</Creación><Descripción>agetty abre un puerto tty, pide un nombre de entrada e invoca el comando /bin/login Es llamado normalmente por init(8) agetty tiene algunas características no-estandares que son útiles para líneas de </Descripción>
<ID>969</ID><Size>5471</Size><Creación>Fri Dec  8 10:21:46 2017</Creación><Descripción>Arp manipula la cache ARP del sistema de varias maneras Las opciones primarias son las de eliminar una entrada de asociación de direcciones y configurar otra manualmente Para propósitos de depuración </Descripción>
<ID>970</ID><Size>1965</Size><Creación>Fri Dec  8 10:21:46 2017</Creación><Descripción>atd ejecuta comandos encolados por at(1) OPCIONES -l Especifica un factor limitador de carga, por encima del cual los trabajos por lotes no deberían ejecutarse, en vez de la elección en tiempo de comp</Descripción>
<ID>971</ID><Size>532</Size><Creación>Fri Dec  8 10:21:46 2017</Creación><Descripción>atrun ejecuta trabajos encolados por at(1) Es un guión shell que contiene una llamada ${exec_prefix}/sbin/atd con la opción -s, y se proporciona por compatibilidad con instalaciones antiguas local 26 </Descripción>
<ID>972</ID><Size>5664</Size><Creación>Fri Dec  8 10:21:46 2017</Creación><Descripción>bdflush se usa para iniciar el demonio del núcleo para vaciar buffers sucios hacia el disco El trabajo sucio real está en una función del núcleo y bdflush realmente desdobla un nuevo proceso que enton</Descripción>
<ID>973</ID><Size>445</Size><Creación>Fri Dec  8 10:21:46 2017</Creación><Descripción>En las primeras versiones de RAID, ckraid comprobaba la consistencia de un array de dispositivos RAID Ahora, todo este trabajo lo realiza el núcleo VÉASE TAMBIÉN raidtab(5), mkraid(8), raidstart(8) ra</Descripción>
<ID>974</ID><Size>1281</Size><Creación>Fri Dec  8 10:21:46 2017</Creación><Descripción>Examinando el código en linux/kernel/sys.c, está claro que la secuencia Ctrl-Alt-Supr puede realizar dos funciones distintas soportadas; un rearranque duro, que rearranca inmediatamente el computador </Descripción>
<ID>975</ID><Size>6940</Size><Creación>Fri Dec  8 10:21:46 2017</Creación><Descripción>cytune interroga y modifica el umbral de interrupción para el controlador de Cyclades Cada línea serie de una tarjeta Cyclades tiene un FIFO de 12 B para la entrada, y otro igual para la salida El "um</Descripción>
<ID>976</ID><Size>24756</Size><Creación>Fri Dec  8 10:21:46 2017</Creación><Descripción>dip maneja las conexiones necesarias para enlaces IP conmutados, como lo son PPP o puede manejar tanto conexiones entrantes como salientes, usando palabras clave de seguridad para las conexiones entra</Descripción>
<ID>977</ID><Size>24756</Size><Creación>Fri Dec  8 10:21:46 2017</Creación><Descripción>dip maneja las conexiones necesarias para enlaces IP conmutados, como lo son PPP o puede manejar tanto conexiones entrantes como salientes, usando palabras clave de seguridad para las conexiones entra</Descripción>
<ID>978</ID><Size>5717</Size><Creación>Fri Dec  8 10:21:46 2017</Creación><Descripción>shutdown cierra el sistema de modo seguro Todos los usuarios conectados son notificados de que el sistema se está cerrando, y login(1) es bloqueado Es posible cerrar al sistema inmediatamente o tras u</Descripción>
<ID>979</ID><Size>5717</Size><Creación>Fri Dec  8 10:21:46 2017</Creación><Descripción>shutdown cierra el sistema de modo seguro Todos los usuarios conectados son notificados de que el sistema se está cerrando, y login(1) es bloqueado Es posible cerrar al sistema inmediatamente o tras u</Descripción>
<ID>980</ID><Size>11081</Size><Creación>Fri Dec  8 10:21:46 2017</Creación><Descripción>Los discos duros pueden dividirse en uno o más discos lógicos llamados las particiones Esta división se describe en la tabla de particiones y se encuentra en el sector número 0 del disco En el mundo B</Descripción>
<ID>981</ID><Size>1493</Size><Creación>Fri Dec  8 10:21:46 2017</Creación><Descripción>frag mostrará la fragmentación del sistema de ficheros en un nombre-fichero especificado Si el nombre-fichero es un directorio, frag descenderá recursivamente por él OPCIONES -s Silencioso (puede pone</Descripción>
<ID>982</ID><Size>5072</Size><Creación>Fri Dec  8 10:21:46 2017</Creación><Descripción>fsck.minix realiza una comprobación de consistencia para el sistema de ficheros MINIX de Linux La versión actual admite las opciones de nombre de fichero de 14 caracteres y de 30 caracteres El program</Descripción>
<ID>983</ID><Size>1726</Size><Creación>Fri Dec  8 10:21:46 2017</Creación><Descripción>--NO POSEE DESCRIPCIÓN--</Descripción>
<ID>984</ID><Size>521</Size><Creación>Fri Dec  8 10:21:46 2017</Creación><Descripción>La orden getkeycodes muestra la tabla del núcleo de asociaciones de códigos de rastreos a códigoso de teclas OPCIONES Ninguna VÉASE TAMBIÉN setkeycodes (8) Local 8 de Noviembre de 1994 GETKEYCODES(8) </Descripción>
<ID>985</ID><Size>20150</Size><Creación>Fri Dec  8 10:21:46 2017</Creación><Descripción>Este paquete intenta ser un servidor de raton útil para las aplicaciones que se ejecutan en la consola de Linux Está basado en el paquete llamado "selección", y algunas partes de su código provienen d</Descripción>
<ID>986</ID><Size>1856</Size><Creación>Fri Dec  8 10:21:46 2017</Creación><Descripción>--NO POSEE DESCRIPCIÓN--</Descripción>
<ID>987</ID><Size>15481</Size><Creación>Fri Dec  8 10:21:46 2017</Creación><Descripción>hwclock es una herramienta para acceder al Reloj del Hardware Ud puede mostrar la hora actual, poner el Reloj del Hardware a una hora especificada, poner el Reloj del Hardware a la Hora del Sistema, y</Descripción>
<ID>988</ID><Size>7972</Size><Creación>Fri Dec  8 10:21:46 2017</Creación><Descripción>Ifconfig se usa para configurar los interfaces de red residentes en el núcleo Se utiliza durante el arranque para configurar aquellos interfaces que se necesiten Tras esto, normalmente sólo se necesit</Descripción>
<ID>989</ID><Size>6892</Size><Creación>Fri Dec  8 10:21:46 2017</Creación><Descripción>Inetd debería ejecutarse en el arranque mediante /etc/rc.local (véase rc(8)) A partir de ese momento está a la escucha de conexiones en cierto conector (socket) de internet Cuando encuentra una conexi</Descripción>
<ID>990</ID><Size>11800</Size><Creación>Fri Dec  8 10:21:46 2017</Creación><Descripción>Init Init es el padre de todos los procesos Su papel primario es crear procesos a partir de un guión guardado en el fichero /etc/inittab (véase inittab(5)) Este fichero normalmente tiene entradas que </Descripción>
<ID>991</ID><Size>624</Size><Creación>Fri Dec  8 10:21:46 2017</Creación><Descripción>Este capítulo describe las órdenes que puedan ser o sean exclusivas del superusuario, por ejemplo, demonios y órdenes relacionadas con el ordenador o periféricos AUTORES Los autores y derechos de auto</Descripción>
<ID>992</ID><Size>23651</Size><Creación>Fri Dec  8 10:21:46 2017</Creación><Descripción>Ipchains se usa para configurar, mantener e inspeccioar las reglas de cortafuegos IP del núcleo Linux Estas reglas se pueden dividir en 4 categorías diferentes: la cadena de entrada IP, la cadena de s</Descripción>
<ID>993</ID><Size>420</Size><Creación>Fri Dec  8 10:21:46 2017</Creación><Descripción>ipcrm borrará el recurso especificado por id VÉASE TAMBIÉN ipcs(8) AUTOR krishna balasubramanian (balasub@cis.ohio-state.edu) Linux 0.99 9 Octubre 1993 IPCRM(8) </Descripción>
<ID>994</ID><Size>1220</Size><Creación>Fri Dec  8 10:21:46 2017</Creación><Descripción>ipcs proporciona información sobre los recursos del ipc para los cuales el proceso que llama tiene acceso de lectura La opción -i permite que se especifique un id de un recurso determinado Sólo se mos</Descripción>
<ID>995</ID><Size>18815</Size><Creación>Fri Dec  8 10:21:46 2017</Creación><Descripción>Ipfwadm se utiliza para configurar, mantener e inspeccionar los cortafuegos IP y las reglas de contabilidad del núcleo Linux Estas reglas se pueden dividir en cuatro categorías diferentes: contabilida</Descripción>
<ID>996</ID><Size>689</Size><Creación>Fri Dec  8 10:21:46 2017</Creación><Descripción>killall5 es el comando killall de SystemV Envía una señal a todos los procesos excepto al de su propia sesión, para no eliminar el shell que ejecutó el guión desde el que fue llamado Su uso principal </Descripción>
<ID>997</ID><Size>3873</Size><Creación>Fri Dec  8 10:21:46 2017</Creación><Descripción>--NO POSEE DESCRIPCIÓN--</Descripción>
<ID>998</ID><Size>6779</Size><Creación>Fri Dec  8 10:21:46 2017</Creación><Descripción>lilo instala un cargador de arranque que se activará la próxima vez que se arranque el sistema Posee numerosas opciones -v Ordena a lilo dar mayor información al usuario durante la ejecución La cantid</Descripción>
<ID>999</ID><Size>938</Size><Creación>Fri Dec  8 10:21:46 2017</Creación><Descripción>El programa loadunimap carga en la tabla del núcleo de asociaciones unicode a tipo de letra el mapa especificado Si no se da ninguno se asume def La extensión predeterminada (i.e., que puede omitirse)</Descripción>
<ID>1000</ID><Size>13601</Size><Creación>Fri Dec  8 10:21:46 2017</Creación><Descripción>Logrotate ha sido diseñado para facilitar la administración de sistemas que generan gran cantidad de archivos de registro (logs) El programa permite el cambio, compresión, eliminación y envío automáti</Descripción>
<ID>1001</ID><Size>2354</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>La orden mapscrn carga una tabla de mapas de caracteres de salida definida por el usuario en el controlador de consola Éste puede ser puesto más tarde en un modo de usar tabla de mapas definida por el</Descripción>
<ID>1002</ID><Size>3202</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>mcserv es el programa servidor para el sistema de ficheros de red de Midnight Commander Proporciona acceso al sistema de ficheros del host a los clientes ejecutando el sistema de ficheros Midnight (ac</Descripción>
<ID>1003</ID><Size>3859</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>mkfs se emplea para construir un sistema de ficheros de Linux sobre un dispositivo, usualmente una partición de un disco duro sistema-de-ficheros es o el nombre del dispositivo (como por ejemplo /dev/</Descripción>
<ID>1004</ID><Size>3142</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>mkfs crea un sistema de ficheros MINIX en Linux sobre un dispositivo (usualmente una partición de disco) El dispositivo es normalmente de la forma siguiente: /dev/hda[1-8] (primer disco IDE) /dev/hdb[</Descripción>
<ID>1005</ID><Size>1464</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>mkpv configura varios dispositivo de bloques en un único PV Dése cuenta que la inicialización de dispositivos PV destruye todos los datos de los dispositivos constituyentes OPCIONS -c, --configfile no</Descripción>
<ID>1006</ID><Size>2122</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>mkraid configura un conjunto de dispositivos de bloques en un único array RAID Busca en su fichero de configuración los dispositivos md mencionados en la línea de órdenes e inicializa esos arrays mkdr</Descripción>
<ID>1007</ID><Size>3353</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>mkswap establece un área de trasiego para Linux sobre un dispositivo o en un fichero El dispositivo es usualmente de la forma siguiente: /dev/hda[1-8] /dev/hdb[1-8] /dev/sda[1-8] /dev/sdb[1-8] El pará</Descripción>
<ID>1008</ID><Size>36904</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>Todos los ficheros accesibles en un sistema Unix están dispuestos en un gran árbol, la jerarquía de ficheros, con la raíz en / Estos ficheros pueden estar distribuidos sobre varios dispositivos La ord</Descripción>
<ID>1009</ID><Size>12050</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>Netstat muestra información de los subsistemas de red en Linux (sin opciones) Se puede ver el estado de las conexiones de red al listar los conectores (sockets) abiertos Esta es la operación por defec</Descripción>
<ID>1010</ID><Size>1554</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>Pidof busca el id del proceso del nombre del programa Imprime los ids a la salida estándar Es usado generalmente en guiones que cambian el nivel de ejecución, especialmente cuando el sistema tiene el </Descripción>
<ID>1011</ID><Size>10351</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>Ping utiliza el datagrama obligatorio ICMP del protocolo ECHO_REQUEST para solicitar una ICMP ECHO_RESPONSE por parte de un servidor o una puerta de acceso Los datagramas ECHO_REQUEST ("pings") tienen</Descripción>
<ID>1012</ID><Size>1856</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>--NO POSEE DESCRIPCIÓN--</Descripción>
<ID>1013</ID><Size>2505</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>psupdate actualiza el fichero /etc/psdatabase para que corresponda al mapa del sistema del kernel actual, por defecto /usr/src/linux/vmlinux Opciones Si su fichero de mapa del sistema no es /usr/src/l</Descripción>
<ID>1014</ID><Size>284</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>--NO POSEE DESCRIPCIÓN--</Descripción>
<ID>1015</ID><Size>282</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>--NO POSEE DESCRIPCIÓN--</Descripción>
<ID>1016</ID><Size>3215</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>Los dispositivos RAID son dispositivos virtuales creados a partir de 2 o más dispositivos de bloques reales Esto permite combinar varios discos en un único sistema de ficheros, posiblemente con mecani</Descripción>
<ID>1017</ID><Size>3215</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>Los dispositivos RAID son dispositivos virtuales creados a partir de 2 o más dispositivos de bloques reales Esto permite combinar varios discos en un único sistema de ficheros, posiblemente con mecani</Descripción>
<ID>1018</ID><Size>4417</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>Sin argumentos, rdev imprime la línea de /etc/mtab con el sistema de ficheros raíz actual Sin argumentos, swapdev, ramsize, vidmode y rootflags imprimen información sobre su uso En una imagen de arran</Descripción>
<ID>1019</ID><Size>2767</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>Rarp manipula la tabla RARP del núcleo de varias maneras Las opciones primarias son las de borrar una entrada de mapeado de dirección y establecer una nueva manualmente Para propósitos de depuración, </Descripción>
<ID>1020</ID><Size>4417</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>Sin argumentos, rdev imprime la línea de /etc/mtab con el sistema de ficheros raíz actual Sin argumentos, swapdev, ramsize, vidmode y rootflags imprimen información sobre su uso En una imagen de arran</Descripción>
<ID>1021</ID><Size>1856</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>--NO POSEE DESCRIPCIÓN--</Descripción>
<ID>1022</ID><Size>2608</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>Renice altera la prioridad de planificación de uno o más procesos en ejecución Los siguientes parámetros quién son interpretados como ID's de proceso, ID's de grupo de proceso, o nombres de usuario Ap</Descripción>
<ID>1023</ID><Size>2832</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>La orden resizecons intenta cambiar el modo de vídeo de la consola Esto tiene varios aspectos: (a) el núcleo debe saber acerca de esto, (b) el equipo también debe saber de esto, (c) los programas de u</Descripción>
<ID>1024</ID><Size>4417</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>Sin argumentos, rdev imprime la línea de /etc/mtab con el sistema de ficheros raíz actual Sin argumentos, swapdev, ramsize, vidmode y rootflags imprimen información sobre su uso En una imagen de arran</Descripción>
<ID>1025</ID><Size>10736</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>Route manipula la tabla de encaminamiento IP del kernel Su uso fundamental es el de establecer rutas estáticas hacia ordenadores o redes específicos vía interfaces previamente configuradas con el prog</Descripción>
<ID>1026</ID><Size>1185</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>Runlevel lee el archivo de sistema utmp (generalmente /var/run/utmp) para localizar el nivel salvado e imprimir el estado actual y el anterior en la salida estándar, separados por un simple espacio Si</Descripción>
<ID>1027</ID><Size>2265</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>setfdprm es una utilidad que puede emplearse para cargar parámetros de disco en los dispositivos de disco flexible auto-detectables, para borrar antiguos conjuntos de parámetros y para deshabilitar o </Descripción>
<ID>1028</ID><Size>3630</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>La orden setfont carga un tipo de letra en el generador de caracteres EGA/VGA, y opcionalmente muestra en la salida el tipo anterior Esta orden lee un tipo 8×H desde el fichero y lo carga en la memori</Descripción>
<ID>1029</ID><Size>2794</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>La orden setkeycodes lee sus argumentos de dos en dos, consistiendo cada par de ellos en un código de rastreo (dado en hexadecimal) y un código de tecla (en base 10) Para cada par, le dice al controla</Descripción>
<ID>1030</ID><Size>413</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>setsid ejecuta un programa en una nueva sesión VÉASE TAMBIÉN setsid(2) AUTOR Rick Sladkey <jrs@world.std.com> Linux 0.99 20 Noviembre 1993 SETSID(8) </Descripción>
<ID>1031</ID><Size>5717</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>shutdown cierra el sistema de modo seguro Todos los usuarios conectados son notificados de que el sistema se está cerrando, y login(1) es bloqueado Es posible cerrar al sistema inmediatamente o tras u</Descripción>
<ID>1032</ID><Size>4093</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>init se lanza en el último paso de la secuencia de arranque en Linux Si se emplea la opción single, o si existe el fichero /etc/singleboot, entonces se entrará en el modo monousuario, arrancando /bin/</Descripción>
<ID>1033</ID><Size>2250</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>sulogin es llamado por init(8) cuando el sistema comienza en modo monousuario (esto se hace a través de una entrada en inittab(5)) Init también intenta ejecutar sulogin cuando se le pasa el flag -b de</Descripción>
<ID>1034</ID><Size>4417</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>Sin argumentos, rdev imprime la línea de /etc/mtab con el sistema de ficheros raíz actual Sin argumentos, swapdev, ramsize, vidmode y rootflags imprimen información sobre su uso En una imagen de arran</Descripción>
<ID>1035</ID><Size>2724</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>Swapon se emplea para especificar dispositivos sobre los cuales van a tener lugar las actividades de paginado y trasiego Las llamadas a swapon se hacen normalmente en el fichero de inicio del sistema </Descripción>
<ID>1036</ID><Size>2724</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>Swapon se emplea para especificar dispositivos sobre los cuales van a tener lugar las actividades de paginado y trasiego Las llamadas a swapon se hacen normalmente en el fichero de inicio del sistema </Descripción>
<ID>1037</ID><Size>11800</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>Init Init es el padre de todos los procesos Su papel primario es crear procesos a partir de un guión guardado en el fichero /etc/inittab (véase inittab(5)) Este fichero normalmente tiene entradas que </Descripción>
<ID>1038</ID><Size>5801</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>tunelp establece varios parámetros para los dispositivos /dev/lp?, para mejorar el rendimiento (o para cualquier rendimiento, si su impresora no habrá de funcionar sin esto ) Sin parámetros, dice si e</Descripción>
<ID>1039</ID><Size>1612</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>El programa tzselect pide al usuario información sobre la localización actual y muestra en la salida estándar la descripción de huso horario resultante La salida es adecuada como valor para la variabl</Descripción>
<ID>1040</ID><Size>2782</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>La orden umount despega de la jerarquía o árbol de ficheros el/los sistema(s) de ficheros mencionado(s) Un sistema de ficheros se puede especificar bien dando el directorio donde ha sido montado, o bi</Descripción>
<ID>1041</ID><Size>5664</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>bdflush se usa para iniciar el demonio del núcleo para vaciar buffers sucios hacia el disco El trabajo sucio real está en una función del núcleo y bdflush realmente desdobla un nuevo proceso que enton</Descripción>
<ID>1042</ID><Size>4417</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>Sin argumentos, rdev imprime la línea de /etc/mtab con el sistema de ficheros raíz actual Sin argumentos, swapdev, ramsize, vidmode y rootflags imprimen información sobre su uso En una imagen de arran</Descripción>
<ID>1043</ID><Size>1070</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>Vipw edita el fichero de cuentas tras establecer los bloqueos apropiados, y hace cualquier procesado que sea necesario después de que el fichero de cuentas se desbloquee Si el fichero de cuentas ya es</Descripción>
<ID>1044</ID><Size>1070</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>Vipw edita el fichero de cuentas tras establecer los bloqueos apropiados, y hace cualquier procesado que sea necesario después de que el fichero de cuentas se desbloquee Si el fichero de cuentas ya es</Descripción>
<ID>1045</ID><Size>3094</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>vmstat da información sobre procesos, memoria, paginación, E/S de bloque, trampas, y actividad de la CPU El primer informe producido da medias desde el último arranque Los adicionales dan información </Descripción>
<ID>1046</ID><Size>1278</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>Zdump muestra la hora actual en cada nombrezona indicada en la línea de órdenes Están disponibles estas opciones: -v Para cada nombrezona de la línea de órdenes, muestra la hora en el valor de tiempo </Descripción>
<ID>1047</ID><Size>12328</Size><Creación>Fri Dec  8 10:21:47 2017</Creación><Descripción>Zic lee el texto del fichero (los ficheros) indicado(s) en la línea de órdenes y crea los ficheros de información de conversione horarias indicados en esta entrada Si un filename es -, se lee la entra</Descripción>
